
use std::ffi::{ CString }; 
use libc;


use super::errors::*;
use super::bnfc;
use super::normalize::*;



pub fn build_ast(source: &str) -> std::result::Result<(), CompliationError> {
    
    let raw_source = CString::new(source)?.into_raw();
    let raw_mode = CString::new("r")?.into_raw();

    let proc : bnfc::Proc;
    let mem_file : *mut libc::FILE;
    unsafe {
        // There are two editions (psProc / pProc) generated by BNFC
        // psProc accepts C-string while pProc accepts FILE*
        // However, it turns out psProc leaks memory  https://github.com/BNFC/bnfc/issues/347
        // here use pProc to stream C-string as FILE* to avoid memory leaks
        let buf_ptr: *mut libc::c_void = raw_source as *mut libc::c_void;
        mem_file = libc::fmemopen( buf_ptr, source.len(), raw_mode);
        if mem_file == 0 as *mut libc::FILE {
            return Err(CompliationError::FileMemOpenFailed);
        }
        let io_file: *mut bnfc::FILE = mem_file as *mut _ as *mut bnfc::FILE;
        proc = bnfc::pProc(io_file);
        
    };

   

    normalize(proc);

    unsafe {
        libc::fclose(mem_file);

        // retake ownership to avoid memory leak
        CString::from_raw(raw_source);
        CString::from_raw(raw_mode);

        
    }

    Ok(())

}



// traverse abstract syntax tree
// note that even if error occurs, still we need complete the traverse to free all node's memory
fn normalize(p : bnfc::Proc) {
    proc::normalize_match(p, ProcVisitInputs::default());
}

