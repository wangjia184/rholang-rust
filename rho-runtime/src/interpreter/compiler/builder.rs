
use std::ffi::{ CStr, CString }; // https://bnfc.digitalgrammars.com/tutorial/bnfc-tutorial.html
use libc;

use super::errors::*;
use super::bnfc;




pub fn build_ast(source: &str) -> std::result::Result<(), CompliationError> {
    
    let raw_source = CString::new(source)?.into_raw();
    let raw_mode = CString::new("r")?.into_raw();

    let proc : bnfc::Proc;
    let mem_file : *mut libc::FILE;
    unsafe {
        // There are two editions (psProc / pProc) generated by BNFC
        // psProc accepts C-string while pProc accepts FILE*
        // However, it turns out psProc leaks memory  https://github.com/BNFC/bnfc/issues/347
        // here use pProc to stream C-string as FILE* to avoid memory leaks
        let buf_ptr: *mut libc::c_void = raw_source as *mut libc::c_void;
        mem_file = libc::fmemopen( buf_ptr, source.len(), raw_mode);
        if mem_file == 0 as *mut libc::FILE {
            return Err(CompliationError::FileMemOpenFailed);
        }
        let io_file: *mut bnfc::FILE = mem_file as *mut _ as *mut bnfc::FILE;
        proc = bnfc::pProc(io_file);
        
    };

    traverse_ast(proc);

    unsafe {
        libc::fclose(mem_file);

        // retake ownership to avoid memory leak
        CString::from_raw(raw_source);
        CString::from_raw(raw_mode);

        libc::free(proc as *mut libc::c_void);
    }

    Ok(())

}

#[allow(non_snake_case)]
fn traverse_ast(p : bnfc::Proc) {
    let proc;
    unsafe { proc = *p; }

    match proc.kind {
        bnfc::Proc__is_PNew => {
            println!("{}", proc.kind);
        },
        bnfc::Proc__is_PNil => {
            println!("{}", proc.kind);
        },
        bnfc::Proc__is_PPar => {
            println!("{}", proc.kind);
        },
        _ => { println!("Unknown kind {:?}", proc.kind); }
    };
}