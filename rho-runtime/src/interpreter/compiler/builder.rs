
use std::ffi::{ CStr, CString }; 
use std::os::raw::c_char;
use libc;

use super::errors::*;
use super::bnfc;




pub fn build_ast(source: &str) -> std::result::Result<(), CompliationError> {
    
    let raw_source = CString::new(source)?.into_raw();
    let raw_mode = CString::new("r")?.into_raw();

    let proc : bnfc::Proc;
    let mem_file : *mut libc::FILE;
    unsafe {
        // There are two editions (psProc / pProc) generated by BNFC
        // psProc accepts C-string while pProc accepts FILE*
        // However, it turns out psProc leaks memory  https://github.com/BNFC/bnfc/issues/347
        // here use pProc to stream C-string as FILE* to avoid memory leaks
        let buf_ptr: *mut libc::c_void = raw_source as *mut libc::c_void;
        mem_file = libc::fmemopen( buf_ptr, source.len(), raw_mode);
        if mem_file == 0 as *mut libc::FILE {
            return Err(CompliationError::FileMemOpenFailed);
        }
        let io_file: *mut bnfc::FILE = mem_file as *mut _ as *mut bnfc::FILE;
        proc = bnfc::pProc(io_file);
        
    };

    visit_proc(proc);

    unsafe {
        libc::fclose(mem_file);

        // retake ownership to avoid memory leak
        CString::from_raw(raw_source);
        CString::from_raw(raw_mode);

        
    }

    Ok(())

}

// traverse abstract syntax tree
// note that even ifs error occurs, still we need complete the traverse to free all node's memorys
fn visit_proc(p : bnfc::Proc) {
    if p == 0 as bnfc::Proc {
        return; // NULL pointer
    }

    let proc = unsafe { *p };

    match proc.kind {
        bnfc::Proc__is_PPar => {
            trace!("PPar at {}:{}", proc.line_number, proc.char_number);
            let proc_1 = unsafe { proc.u.ppar_.proc_1 };
            let proc_2 = unsafe { proc.u.ppar_.proc_2 };
            visit_proc(proc_1);
            visit_proc(proc_2);
        },
        bnfc::Proc__is_PIf => {
            trace!("PIf at {}:{}", proc.line_number, proc.char_number);
            let proc_1 = unsafe { proc.u.pif_.proc_1 };
            let proc_2 = unsafe { proc.u.pif_.proc_2 };
            visit_proc(proc_1);
            visit_proc(proc_2);
        },
        bnfc::Proc__is_PIfElse => {
            trace!("PIfElse at {}:{}", proc.line_number, proc.char_number);
            let proc_1 = unsafe { proc.u.pifelse_.proc_1 };
            let proc_2 = unsafe { proc.u.pifelse_.proc_2 };
            let proc_3 = unsafe { proc.u.pifelse_.proc_3 };
            visit_proc(proc_1);
            visit_proc(proc_2);
            visit_proc(proc_3);
        },
        bnfc::Proc__is_PNew => {
            trace!("PNew at {}:{}", proc.line_number, proc.char_number);
            let listnamedecl = unsafe { proc.u.pnew_.listnamedecl_ };
            let sub_proc = unsafe { proc.u.pnew_.proc_ };
            visit_list_name_decl(listnamedecl);
            visit_proc(sub_proc);
        },
        bnfc::Proc__is_PContr => {
            trace!("PContr at {}:{}", proc.line_number, proc.char_number);
        },
        bnfc::Proc__is_PInput => {
            trace!("PInput at {}:{}", proc.line_number, proc.char_number);
        },
        bnfc::Proc__is_PNil => {
            trace!("PNil at {}:{}", proc.line_number, proc.char_number);
        },
        
        _ => { println!("Unknown token {:?}", proc.kind); }
    };

    // release memory
    unsafe { libc::free(p as *mut libc::c_void); }
}


fn visit_list_name_decl(mut listnamedecl : bnfc::ListNameDecl)
{
  while listnamedecl != 0 as bnfc::ListNameDecl
  {
    let p = unsafe { *listnamedecl };
    visit_name_decl(p.namedecl_);
    listnamedecl = p.listnamedecl_;
  }
}


fn visit_name_decl(namedecl : bnfc::NameDecl)
{
    if namedecl != 0 as bnfc::NameDecl {
        let p = unsafe { *namedecl };
        match p.kind {
            bnfc::NameDecl__is_NameDeclSimpl => {
                let var = unsafe { p.u.namedeclsimpl_.var_ };
                let var_name = get_string(var);
                trace!("{:?} at {}:{}", &var_name, p.line_number, p.char_number);
            },
            bnfc::NameDecl__is_NameDeclUrn => {
                let var = unsafe { p.u.namedeclurn_.var_ };
                let var_name = get_string(var);
                trace!("{:?} at {}:{}", &var_name, p.line_number, p.char_number);
                // visitUriLiteral(p->u.namedeclurn_.uriliteral_);
            },
            _ => {
                warn!("Unrecognized kind {} in bnfc::NameDecl", p.kind);
            }
        };
    }
}

fn get_string(raw_str : bnfc::String) -> Result<String, std::str::Utf8Error> {
    unsafe {
        let raw_pointer = raw_str as *const _ as *const c_char;
        CStr::from_ptr(raw_pointer).to_str().and_then( |s| {
            Ok(s.to_owned())
        })
    }
}