
use std::ffi::{ CString }; // https://bnfc.digitalgrammars.com/tutorial/bnfc-tutorial.html
use libc;

use super::errors::*;
use super::bnfc;




pub fn build_ast(source: &str) -> std::result::Result<(), CompliationError> {
    
    let raw_source = CString::new(source)?.into_raw();
    let raw_mode = CString::new("r")?.into_raw();

    let proc : bnfc::Proc;
    let mem_file : *mut libc::FILE;
    unsafe {
        // There are two editions (psProc / pProc) generated by BNFC
        // psProc accepts C-string while pProc accepts FILE*
        // However, it turns out psProc leaks memory  https://github.com/BNFC/bnfc/issues/347
        // here use pProc to stream C-string as FILE* to avoid memory leaks
        let buf_ptr: *mut libc::c_void = raw_source as *mut libc::c_void;
        mem_file = libc::fmemopen( buf_ptr, source.len(), raw_mode);
        if mem_file == 0 as *mut libc::FILE {
            return Err(CompliationError::FileMemOpenFailed);
        }
        let io_file: *mut bnfc::FILE = mem_file as *mut _ as *mut bnfc::FILE;
        proc = bnfc::pProc(io_file);
        
    };

    visit_proc(proc);

    unsafe {
        libc::fclose(mem_file);

        // retake ownership to avoid memory leak
        CString::from_raw(raw_source);
        CString::from_raw(raw_mode);

        
    }

    Ok(())

}

// traverse abstract syntax tree
fn visit_proc(p : bnfc::Proc) {
    if p == 0 as bnfc::Proc {
        return; // NULL pointer
    }

    let proc = unsafe { *p };

    match proc.kind {
        bnfc::Proc__is_PPar => {
            trace!("PPar");
            let proc_1 = unsafe { proc.u.ppar_.proc_1 };
            let proc_2 = unsafe { proc.u.ppar_.proc_2 };
            visit_proc(proc_1);
            visit_proc(proc_2);
        },
        bnfc::Proc__is_PIf => {
            trace!("PIf");
            let proc_1 = unsafe { proc.u.pif_.proc_1 };
            let proc_2 = unsafe { proc.u.pif_.proc_2 };
            visit_proc(proc_1);
            visit_proc(proc_2);
        },
        bnfc::Proc__is_PIfElse => {
            trace!("PIfElse");
            let proc_1 = unsafe { proc.u.pifelse_.proc_1 };
            let proc_2 = unsafe { proc.u.pifelse_.proc_2 };
            let proc_3 = unsafe { proc.u.pifelse_.proc_3 };
            visit_proc(proc_1);
            visit_proc(proc_2);
            visit_proc(proc_3);
        },
        bnfc::Proc__is_PNew => {
            trace!("PNew");
            let _listnamedecl = unsafe { proc.u.pnew_.listnamedecl_ };
            let sub_proc = unsafe { proc.u.pnew_.proc_ };

            visit_proc(sub_proc);
        },
        bnfc::Proc__is_PNil => {
            trace!("PNil");
        },
        
        _ => { println!("Unknown kind {:?}", proc.kind); }
    };

    // release memory
    unsafe { libc::free(p as *mut libc::c_void); }
}