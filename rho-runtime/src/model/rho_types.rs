// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `rho_types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Par {
    // message fields
    pub sends: ::protobuf::RepeatedField<Send>,
    pub receives: ::protobuf::RepeatedField<Receive>,
    pub news: ::protobuf::RepeatedField<New>,
    pub exprs: ::protobuf::RepeatedField<Expr>,
    pub matches: ::protobuf::RepeatedField<Match>,
    pub unforgeables: ::protobuf::RepeatedField<GUnforgeable>,
    pub bundles: ::protobuf::RepeatedField<Bundle>,
    pub connectives: ::protobuf::RepeatedField<Connective>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Par {
    fn default() -> &'a Par {
        <Par as ::protobuf::Message>::default_instance()
    }
}

impl Par {
    pub fn new() -> Par {
        ::std::default::Default::default()
    }

    // repeated .Send sends = 1;


    pub fn get_sends(&self) -> &[Send] {
        &self.sends
    }
    pub fn clear_sends(&mut self) {
        self.sends.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends(&mut self, v: ::protobuf::RepeatedField<Send>) {
        self.sends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sends(&mut self) -> &mut ::protobuf::RepeatedField<Send> {
        &mut self.sends
    }

    // Take field
    pub fn take_sends(&mut self) -> ::protobuf::RepeatedField<Send> {
        ::std::mem::replace(&mut self.sends, ::protobuf::RepeatedField::new())
    }

    // repeated .Receive receives = 2;


    pub fn get_receives(&self) -> &[Receive] {
        &self.receives
    }
    pub fn clear_receives(&mut self) {
        self.receives.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives(&mut self, v: ::protobuf::RepeatedField<Receive>) {
        self.receives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_receives(&mut self) -> &mut ::protobuf::RepeatedField<Receive> {
        &mut self.receives
    }

    // Take field
    pub fn take_receives(&mut self) -> ::protobuf::RepeatedField<Receive> {
        ::std::mem::replace(&mut self.receives, ::protobuf::RepeatedField::new())
    }

    // repeated .New news = 4;


    pub fn get_news(&self) -> &[New] {
        &self.news
    }
    pub fn clear_news(&mut self) {
        self.news.clear();
    }

    // Param is passed by value, moved
    pub fn set_news(&mut self, v: ::protobuf::RepeatedField<New>) {
        self.news = v;
    }

    // Mutable pointer to the field.
    pub fn mut_news(&mut self) -> &mut ::protobuf::RepeatedField<New> {
        &mut self.news
    }

    // Take field
    pub fn take_news(&mut self) -> ::protobuf::RepeatedField<New> {
        ::std::mem::replace(&mut self.news, ::protobuf::RepeatedField::new())
    }

    // repeated .Expr exprs = 5;


    pub fn get_exprs(&self) -> &[Expr] {
        &self.exprs
    }
    pub fn clear_exprs(&mut self) {
        self.exprs.clear();
    }

    // Param is passed by value, moved
    pub fn set_exprs(&mut self, v: ::protobuf::RepeatedField<Expr>) {
        self.exprs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exprs(&mut self) -> &mut ::protobuf::RepeatedField<Expr> {
        &mut self.exprs
    }

    // Take field
    pub fn take_exprs(&mut self) -> ::protobuf::RepeatedField<Expr> {
        ::std::mem::replace(&mut self.exprs, ::protobuf::RepeatedField::new())
    }

    // repeated .Match matches = 6;


    pub fn get_matches(&self) -> &[Match] {
        &self.matches
    }
    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<Match>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<Match> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<Match> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    // repeated .GUnforgeable unforgeables = 7;


    pub fn get_unforgeables(&self) -> &[GUnforgeable] {
        &self.unforgeables
    }
    pub fn clear_unforgeables(&mut self) {
        self.unforgeables.clear();
    }

    // Param is passed by value, moved
    pub fn set_unforgeables(&mut self, v: ::protobuf::RepeatedField<GUnforgeable>) {
        self.unforgeables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unforgeables(&mut self) -> &mut ::protobuf::RepeatedField<GUnforgeable> {
        &mut self.unforgeables
    }

    // Take field
    pub fn take_unforgeables(&mut self) -> ::protobuf::RepeatedField<GUnforgeable> {
        ::std::mem::replace(&mut self.unforgeables, ::protobuf::RepeatedField::new())
    }

    // repeated .Bundle bundles = 11;


    pub fn get_bundles(&self) -> &[Bundle] {
        &self.bundles
    }
    pub fn clear_bundles(&mut self) {
        self.bundles.clear();
    }

    // Param is passed by value, moved
    pub fn set_bundles(&mut self, v: ::protobuf::RepeatedField<Bundle>) {
        self.bundles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bundles(&mut self) -> &mut ::protobuf::RepeatedField<Bundle> {
        &mut self.bundles
    }

    // Take field
    pub fn take_bundles(&mut self) -> ::protobuf::RepeatedField<Bundle> {
        ::std::mem::replace(&mut self.bundles, ::protobuf::RepeatedField::new())
    }

    // repeated .Connective connectives = 8;


    pub fn get_connectives(&self) -> &[Connective] {
        &self.connectives
    }
    pub fn clear_connectives(&mut self) {
        self.connectives.clear();
    }

    // Param is passed by value, moved
    pub fn set_connectives(&mut self, v: ::protobuf::RepeatedField<Connective>) {
        self.connectives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connectives(&mut self) -> &mut ::protobuf::RepeatedField<Connective> {
        &mut self.connectives
    }

    // Take field
    pub fn take_connectives(&mut self) -> ::protobuf::RepeatedField<Connective> {
        ::std::mem::replace(&mut self.connectives, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 9;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 10;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for Par {
    fn is_initialized(&self) -> bool {
        for v in &self.sends {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receives {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.news {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exprs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unforgeables {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bundles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connectives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sends)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.receives)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.news)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exprs)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unforgeables)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bundles)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connectives)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.receives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.news {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.exprs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unforgeables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.bundles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.connectives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sends {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.receives {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.news {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.exprs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.matches {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unforgeables {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.bundles {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.connectives {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(9, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(10, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Par {
        Par::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Send>>(
                "sends",
                |m: &Par| { &m.sends },
                |m: &mut Par| { &mut m.sends },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Receive>>(
                "receives",
                |m: &Par| { &m.receives },
                |m: &mut Par| { &mut m.receives },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<New>>(
                "news",
                |m: &Par| { &m.news },
                |m: &mut Par| { &mut m.news },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                "exprs",
                |m: &Par| { &m.exprs },
                |m: &mut Par| { &mut m.exprs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Match>>(
                "matches",
                |m: &Par| { &m.matches },
                |m: &mut Par| { &mut m.matches },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GUnforgeable>>(
                "unforgeables",
                |m: &Par| { &m.unforgeables },
                |m: &mut Par| { &mut m.unforgeables },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bundle>>(
                "bundles",
                |m: &Par| { &m.bundles },
                |m: &mut Par| { &mut m.bundles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Connective>>(
                "connectives",
                |m: &Par| { &m.connectives },
                |m: &mut Par| { &mut m.connectives },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &Par| { &m.locallyFree },
                |m: &mut Par| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &Par| { &m.connective_used },
                |m: &mut Par| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Par>(
                "Par",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Par {
        static instance: ::protobuf::rt::LazyV2<Par> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Par::new)
    }
}

impl ::protobuf::Clear for Par {
    fn clear(&mut self) {
        self.sends.clear();
        self.receives.clear();
        self.news.clear();
        self.exprs.clear();
        self.matches.clear();
        self.unforgeables.clear();
        self.bundles.clear();
        self.connectives.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Par {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Par {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaggedContinuation {
    // message oneof groups
    pub tagged_cont: ::std::option::Option<TaggedContinuation_oneof_tagged_cont>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaggedContinuation {
    fn default() -> &'a TaggedContinuation {
        <TaggedContinuation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TaggedContinuation_oneof_tagged_cont {
    par_body(ParWithRandom),
    scala_body_ref(i64),
}

impl TaggedContinuation {
    pub fn new() -> TaggedContinuation {
        ::std::default::Default::default()
    }

    // .ParWithRandom par_body = 1;


    pub fn get_par_body(&self) -> &ParWithRandom {
        match self.tagged_cont {
            ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(ref v)) => v,
            _ => <ParWithRandom as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_par_body(&mut self) {
        self.tagged_cont = ::std::option::Option::None;
    }

    pub fn has_par_body(&self) -> bool {
        match self.tagged_cont {
            ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_par_body(&mut self, v: ParWithRandom) {
        self.tagged_cont = ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_par_body(&mut self) -> &mut ParWithRandom {
        if let ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(_)) = self.tagged_cont {
        } else {
            self.tagged_cont = ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(ParWithRandom::new()));
        }
        match self.tagged_cont {
            ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_par_body(&mut self) -> ParWithRandom {
        if self.has_par_body() {
            match self.tagged_cont.take() {
                ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ParWithRandom::new()
        }
    }

    // int64 scala_body_ref = 2;


    pub fn get_scala_body_ref(&self) -> i64 {
        match self.tagged_cont {
            ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::scala_body_ref(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_scala_body_ref(&mut self) {
        self.tagged_cont = ::std::option::Option::None;
    }

    pub fn has_scala_body_ref(&self) -> bool {
        match self.tagged_cont {
            ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::scala_body_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scala_body_ref(&mut self, v: i64) {
        self.tagged_cont = ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::scala_body_ref(v))
    }
}

impl ::protobuf::Message for TaggedContinuation {
    fn is_initialized(&self) -> bool {
        if let Some(TaggedContinuation_oneof_tagged_cont::par_body(ref v)) = self.tagged_cont {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tagged_cont = ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::par_body(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tagged_cont = ::std::option::Option::Some(TaggedContinuation_oneof_tagged_cont::scala_body_ref(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.tagged_cont {
            match v {
                &TaggedContinuation_oneof_tagged_cont::par_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TaggedContinuation_oneof_tagged_cont::scala_body_ref(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.tagged_cont {
            match v {
                &TaggedContinuation_oneof_tagged_cont::par_body(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TaggedContinuation_oneof_tagged_cont::scala_body_ref(v) => {
                    os.write_int64(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaggedContinuation {
        TaggedContinuation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ParWithRandom>(
                "par_body",
                TaggedContinuation::has_par_body,
                TaggedContinuation::get_par_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "scala_body_ref",
                TaggedContinuation::has_scala_body_ref,
                TaggedContinuation::get_scala_body_ref,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaggedContinuation>(
                "TaggedContinuation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaggedContinuation {
        static instance: ::protobuf::rt::LazyV2<TaggedContinuation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaggedContinuation::new)
    }
}

impl ::protobuf::Clear for TaggedContinuation {
    fn clear(&mut self) {
        self.tagged_cont = ::std::option::Option::None;
        self.tagged_cont = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaggedContinuation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaggedContinuation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParWithRandom {
    // message fields
    pub body: ::protobuf::SingularPtrField<Par>,
    pub randomState: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParWithRandom {
    fn default() -> &'a ParWithRandom {
        <ParWithRandom as ::protobuf::Message>::default_instance()
    }
}

impl ParWithRandom {
    pub fn new() -> ParWithRandom {
        ::std::default::Default::default()
    }

    // .Par body = 1;


    pub fn get_body(&self) -> &Par {
        self.body.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Par) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Par {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Par {
        self.body.take().unwrap_or_else(|| Par::new())
    }

    // bytes randomState = 2;


    pub fn get_randomState(&self) -> &[u8] {
        &self.randomState
    }
    pub fn clear_randomState(&mut self) {
        self.randomState.clear();
    }

    // Param is passed by value, moved
    pub fn set_randomState(&mut self, v: ::bytes::Bytes) {
        self.randomState = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_randomState(&mut self) -> &mut ::bytes::Bytes {
        &mut self.randomState
    }

    // Take field
    pub fn take_randomState(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.randomState, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for ParWithRandom {
    fn is_initialized(&self) -> bool {
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.randomState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.randomState.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.randomState);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.randomState.is_empty() {
            os.write_bytes(2, &self.randomState)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParWithRandom {
        ParWithRandom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "body",
                |m: &ParWithRandom| { &m.body },
                |m: &mut ParWithRandom| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "randomState",
                |m: &ParWithRandom| { &m.randomState },
                |m: &mut ParWithRandom| { &mut m.randomState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ParWithRandom>(
                "ParWithRandom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ParWithRandom {
        static instance: ::protobuf::rt::LazyV2<ParWithRandom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ParWithRandom::new)
    }
}

impl ::protobuf::Clear for ParWithRandom {
    fn clear(&mut self) {
        self.body.clear();
        self.randomState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParWithRandom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParWithRandom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PCost {
    // message fields
    pub cost: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PCost {
    fn default() -> &'a PCost {
        <PCost as ::protobuf::Message>::default_instance()
    }
}

impl PCost {
    pub fn new() -> PCost {
        ::std::default::Default::default()
    }

    // uint64 cost = 1;


    pub fn get_cost(&self) -> u64 {
        self.cost
    }
    pub fn clear_cost(&mut self) {
        self.cost = 0;
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: u64) {
        self.cost = v;
    }
}

impl ::protobuf::Message for PCost {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cost != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cost, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cost != 0 {
            os.write_uint64(1, self.cost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PCost {
        PCost::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cost",
                |m: &PCost| { &m.cost },
                |m: &mut PCost| { &mut m.cost },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PCost>(
                "PCost",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PCost {
        static instance: ::protobuf::rt::LazyV2<PCost> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PCost::new)
    }
}

impl ::protobuf::Clear for PCost {
    fn clear(&mut self) {
        self.cost = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PCost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PCost {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListParWithRandom {
    // message fields
    pub pars: ::protobuf::RepeatedField<Par>,
    pub randomState: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListParWithRandom {
    fn default() -> &'a ListParWithRandom {
        <ListParWithRandom as ::protobuf::Message>::default_instance()
    }
}

impl ListParWithRandom {
    pub fn new() -> ListParWithRandom {
        ::std::default::Default::default()
    }

    // repeated .Par pars = 1;


    pub fn get_pars(&self) -> &[Par] {
        &self.pars
    }
    pub fn clear_pars(&mut self) {
        self.pars.clear();
    }

    // Param is passed by value, moved
    pub fn set_pars(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.pars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pars(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.pars
    }

    // Take field
    pub fn take_pars(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.pars, ::protobuf::RepeatedField::new())
    }

    // bytes randomState = 2;


    pub fn get_randomState(&self) -> &[u8] {
        &self.randomState
    }
    pub fn clear_randomState(&mut self) {
        self.randomState.clear();
    }

    // Param is passed by value, moved
    pub fn set_randomState(&mut self, v: ::bytes::Bytes) {
        self.randomState = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_randomState(&mut self) -> &mut ::bytes::Bytes {
        &mut self.randomState
    }

    // Take field
    pub fn take_randomState(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.randomState, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for ListParWithRandom {
    fn is_initialized(&self) -> bool {
        for v in &self.pars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pars)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.randomState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.randomState.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.randomState);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pars {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.randomState.is_empty() {
            os.write_bytes(2, &self.randomState)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListParWithRandom {
        ListParWithRandom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "pars",
                |m: &ListParWithRandom| { &m.pars },
                |m: &mut ListParWithRandom| { &mut m.pars },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "randomState",
                |m: &ListParWithRandom| { &m.randomState },
                |m: &mut ListParWithRandom| { &mut m.randomState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListParWithRandom>(
                "ListParWithRandom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListParWithRandom {
        static instance: ::protobuf::rt::LazyV2<ListParWithRandom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListParWithRandom::new)
    }
}

impl ::protobuf::Clear for ListParWithRandom {
    fn clear(&mut self) {
        self.pars.clear();
        self.randomState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListParWithRandom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListParWithRandom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Var {
    // message oneof groups
    pub var_instance: ::std::option::Option<Var_oneof_var_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Var {
    fn default() -> &'a Var {
        <Var as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Var_oneof_var_instance {
    bound_var(i32),
    free_var(i32),
    wildcard(Var_WildcardMsg),
}

impl Var {
    pub fn new() -> Var {
        ::std::default::Default::default()
    }

    // sint32 bound_var = 1;


    pub fn get_bound_var(&self) -> i32 {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::bound_var(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_bound_var(&mut self) {
        self.var_instance = ::std::option::Option::None;
    }

    pub fn has_bound_var(&self) -> bool {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::bound_var(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bound_var(&mut self, v: i32) {
        self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::bound_var(v))
    }

    // sint32 free_var = 2;


    pub fn get_free_var(&self) -> i32 {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::free_var(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_free_var(&mut self) {
        self.var_instance = ::std::option::Option::None;
    }

    pub fn has_free_var(&self) -> bool {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::free_var(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_free_var(&mut self, v: i32) {
        self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::free_var(v))
    }

    // .Var.WildcardMsg wildcard = 3;


    pub fn get_wildcard(&self) -> &Var_WildcardMsg {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::wildcard(ref v)) => v,
            _ => <Var_WildcardMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_wildcard(&mut self) {
        self.var_instance = ::std::option::Option::None;
    }

    pub fn has_wildcard(&self) -> bool {
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::wildcard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wildcard(&mut self, v: Var_WildcardMsg) {
        self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::wildcard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wildcard(&mut self) -> &mut Var_WildcardMsg {
        if let ::std::option::Option::Some(Var_oneof_var_instance::wildcard(_)) = self.var_instance {
        } else {
            self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::wildcard(Var_WildcardMsg::new()));
        }
        match self.var_instance {
            ::std::option::Option::Some(Var_oneof_var_instance::wildcard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wildcard(&mut self) -> Var_WildcardMsg {
        if self.has_wildcard() {
            match self.var_instance.take() {
                ::std::option::Option::Some(Var_oneof_var_instance::wildcard(v)) => v,
                _ => panic!(),
            }
        } else {
            Var_WildcardMsg::new()
        }
    }
}

impl ::protobuf::Message for Var {
    fn is_initialized(&self) -> bool {
        if let Some(Var_oneof_var_instance::wildcard(ref v)) = self.var_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::bound_var(is.read_sint32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::free_var(is.read_sint32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.var_instance = ::std::option::Option::Some(Var_oneof_var_instance::wildcard(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.var_instance {
            match v {
                &Var_oneof_var_instance::bound_var(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
                },
                &Var_oneof_var_instance::free_var(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
                },
                &Var_oneof_var_instance::wildcard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.var_instance {
            match v {
                &Var_oneof_var_instance::bound_var(v) => {
                    os.write_sint32(1, v)?;
                },
                &Var_oneof_var_instance::free_var(v) => {
                    os.write_sint32(2, v)?;
                },
                &Var_oneof_var_instance::wildcard(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Var {
        Var::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "bound_var",
                Var::has_bound_var,
                Var::get_bound_var,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "free_var",
                Var::has_free_var,
                Var::get_free_var,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Var_WildcardMsg>(
                "wildcard",
                Var::has_wildcard,
                Var::get_wildcard,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Var>(
                "Var",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Var {
        static instance: ::protobuf::rt::LazyV2<Var> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Var::new)
    }
}

impl ::protobuf::Clear for Var {
    fn clear(&mut self) {
        self.var_instance = ::std::option::Option::None;
        self.var_instance = ::std::option::Option::None;
        self.var_instance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Var {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Var {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Var_WildcardMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Var_WildcardMsg {
    fn default() -> &'a Var_WildcardMsg {
        <Var_WildcardMsg as ::protobuf::Message>::default_instance()
    }
}

impl Var_WildcardMsg {
    pub fn new() -> Var_WildcardMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Var_WildcardMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Var_WildcardMsg {
        Var_WildcardMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Var_WildcardMsg>(
                "Var.WildcardMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Var_WildcardMsg {
        static instance: ::protobuf::rt::LazyV2<Var_WildcardMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Var_WildcardMsg::new)
    }
}

impl ::protobuf::Clear for Var_WildcardMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Var_WildcardMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Var_WildcardMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bundle {
    // message fields
    pub body: ::protobuf::SingularPtrField<Par>,
    pub writeFlag: bool,
    pub readFlag: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bundle {
    fn default() -> &'a Bundle {
        <Bundle as ::protobuf::Message>::default_instance()
    }
}

impl Bundle {
    pub fn new() -> Bundle {
        ::std::default::Default::default()
    }

    // .Par body = 1;


    pub fn get_body(&self) -> &Par {
        self.body.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Par) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Par {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Par {
        self.body.take().unwrap_or_else(|| Par::new())
    }

    // bool writeFlag = 2;


    pub fn get_writeFlag(&self) -> bool {
        self.writeFlag
    }
    pub fn clear_writeFlag(&mut self) {
        self.writeFlag = false;
    }

    // Param is passed by value, moved
    pub fn set_writeFlag(&mut self, v: bool) {
        self.writeFlag = v;
    }

    // bool readFlag = 3;


    pub fn get_readFlag(&self) -> bool {
        self.readFlag
    }
    pub fn clear_readFlag(&mut self) {
        self.readFlag = false;
    }

    // Param is passed by value, moved
    pub fn set_readFlag(&mut self, v: bool) {
        self.readFlag = v;
    }
}

impl ::protobuf::Message for Bundle {
    fn is_initialized(&self) -> bool {
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.writeFlag = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readFlag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.writeFlag != false {
            my_size += 2;
        }
        if self.readFlag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.writeFlag != false {
            os.write_bool(2, self.writeFlag)?;
        }
        if self.readFlag != false {
            os.write_bool(3, self.readFlag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bundle {
        Bundle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "body",
                |m: &Bundle| { &m.body },
                |m: &mut Bundle| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "writeFlag",
                |m: &Bundle| { &m.writeFlag },
                |m: &mut Bundle| { &mut m.writeFlag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readFlag",
                |m: &Bundle| { &m.readFlag },
                |m: &mut Bundle| { &mut m.readFlag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bundle>(
                "Bundle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bundle {
        static instance: ::protobuf::rt::LazyV2<Bundle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bundle::new)
    }
}

impl ::protobuf::Clear for Bundle {
    fn clear(&mut self) {
        self.body.clear();
        self.writeFlag = false;
        self.readFlag = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bundle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bundle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Send {
    // message fields
    pub chan: ::protobuf::SingularPtrField<Par>,
    pub data: ::protobuf::RepeatedField<Par>,
    pub persistent: bool,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Send {
    fn default() -> &'a Send {
        <Send as ::protobuf::Message>::default_instance()
    }
}

impl Send {
    pub fn new() -> Send {
        ::std::default::Default::default()
    }

    // .Par chan = 1;


    pub fn get_chan(&self) -> &Par {
        self.chan.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chan(&mut self) {
        self.chan.clear();
    }

    pub fn has_chan(&self) -> bool {
        self.chan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan(&mut self, v: Par) {
        self.chan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan(&mut self) -> &mut Par {
        if self.chan.is_none() {
            self.chan.set_default();
        }
        self.chan.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan(&mut self) -> Par {
        self.chan.take().unwrap_or_else(|| Par::new())
    }

    // repeated .Par data = 2;


    pub fn get_data(&self) -> &[Par] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // bool persistent = 3;


    pub fn get_persistent(&self) -> bool {
        self.persistent
    }
    pub fn clear_persistent(&mut self) {
        self.persistent = false;
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: bool) {
        self.persistent = v;
    }

    // bytes locallyFree = 5;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 6;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for Send {
    fn is_initialized(&self) -> bool {
        for v in &self.chan {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persistent = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.persistent != false {
            my_size += 2;
        }
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.persistent != false {
            os.write_bool(3, self.persistent)?;
        }
        if !self.locallyFree.is_empty() {
            os.write_bytes(5, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(6, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Send {
        Send::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "chan",
                |m: &Send| { &m.chan },
                |m: &mut Send| { &mut m.chan },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "data",
                |m: &Send| { &m.data },
                |m: &mut Send| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "persistent",
                |m: &Send| { &m.persistent },
                |m: &mut Send| { &mut m.persistent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &Send| { &m.locallyFree },
                |m: &mut Send| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &Send| { &m.connective_used },
                |m: &mut Send| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Send>(
                "Send",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Send {
        static instance: ::protobuf::rt::LazyV2<Send> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Send::new)
    }
}

impl ::protobuf::Clear for Send {
    fn clear(&mut self) {
        self.chan.clear();
        self.data.clear();
        self.persistent = false;
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Send {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Send {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceiveBind {
    // message fields
    pub patterns: ::protobuf::RepeatedField<Par>,
    pub source: ::protobuf::SingularPtrField<Par>,
    pub remainder: ::protobuf::SingularPtrField<Var>,
    pub freeCount: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveBind {
    fn default() -> &'a ReceiveBind {
        <ReceiveBind as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveBind {
    pub fn new() -> ReceiveBind {
        ::std::default::Default::default()
    }

    // repeated .Par patterns = 1;


    pub fn get_patterns(&self) -> &[Par] {
        &self.patterns
    }
    pub fn clear_patterns(&mut self) {
        self.patterns.clear();
    }

    // Param is passed by value, moved
    pub fn set_patterns(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.patterns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patterns(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.patterns
    }

    // Take field
    pub fn take_patterns(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.patterns, ::protobuf::RepeatedField::new())
    }

    // .Par source = 2;


    pub fn get_source(&self) -> &Par {
        self.source.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Par) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Par {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Par {
        self.source.take().unwrap_or_else(|| Par::new())
    }

    // .Var remainder = 3;


    pub fn get_remainder(&self) -> &Var {
        self.remainder.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remainder(&mut self) {
        self.remainder.clear();
    }

    pub fn has_remainder(&self) -> bool {
        self.remainder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainder(&mut self, v: Var) {
        self.remainder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remainder(&mut self) -> &mut Var {
        if self.remainder.is_none() {
            self.remainder.set_default();
        }
        self.remainder.as_mut().unwrap()
    }

    // Take field
    pub fn take_remainder(&mut self) -> Var {
        self.remainder.take().unwrap_or_else(|| Var::new())
    }

    // int32 freeCount = 4;


    pub fn get_freeCount(&self) -> i32 {
        self.freeCount
    }
    pub fn clear_freeCount(&mut self) {
        self.freeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeCount(&mut self, v: i32) {
        self.freeCount = v;
    }
}

impl ::protobuf::Message for ReceiveBind {
    fn is_initialized(&self) -> bool {
        for v in &self.patterns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remainder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patterns)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remainder)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.freeCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patterns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.freeCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.freeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patterns {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.freeCount != 0 {
            os.write_int32(4, self.freeCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveBind {
        ReceiveBind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "patterns",
                |m: &ReceiveBind| { &m.patterns },
                |m: &mut ReceiveBind| { &mut m.patterns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "source",
                |m: &ReceiveBind| { &m.source },
                |m: &mut ReceiveBind| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "remainder",
                |m: &ReceiveBind| { &m.remainder },
                |m: &mut ReceiveBind| { &mut m.remainder },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "freeCount",
                |m: &ReceiveBind| { &m.freeCount },
                |m: &mut ReceiveBind| { &mut m.freeCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveBind>(
                "ReceiveBind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceiveBind {
        static instance: ::protobuf::rt::LazyV2<ReceiveBind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceiveBind::new)
    }
}

impl ::protobuf::Clear for ReceiveBind {
    fn clear(&mut self) {
        self.patterns.clear();
        self.source.clear();
        self.remainder.clear();
        self.freeCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveBind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveBind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BindPattern {
    // message fields
    pub patterns: ::protobuf::RepeatedField<Par>,
    pub remainder: ::protobuf::SingularPtrField<Var>,
    pub freeCount: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BindPattern {
    fn default() -> &'a BindPattern {
        <BindPattern as ::protobuf::Message>::default_instance()
    }
}

impl BindPattern {
    pub fn new() -> BindPattern {
        ::std::default::Default::default()
    }

    // repeated .Par patterns = 1;


    pub fn get_patterns(&self) -> &[Par] {
        &self.patterns
    }
    pub fn clear_patterns(&mut self) {
        self.patterns.clear();
    }

    // Param is passed by value, moved
    pub fn set_patterns(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.patterns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patterns(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.patterns
    }

    // Take field
    pub fn take_patterns(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.patterns, ::protobuf::RepeatedField::new())
    }

    // .Var remainder = 2;


    pub fn get_remainder(&self) -> &Var {
        self.remainder.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remainder(&mut self) {
        self.remainder.clear();
    }

    pub fn has_remainder(&self) -> bool {
        self.remainder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainder(&mut self, v: Var) {
        self.remainder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remainder(&mut self) -> &mut Var {
        if self.remainder.is_none() {
            self.remainder.set_default();
        }
        self.remainder.as_mut().unwrap()
    }

    // Take field
    pub fn take_remainder(&mut self) -> Var {
        self.remainder.take().unwrap_or_else(|| Var::new())
    }

    // int32 freeCount = 3;


    pub fn get_freeCount(&self) -> i32 {
        self.freeCount
    }
    pub fn clear_freeCount(&mut self) {
        self.freeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeCount(&mut self, v: i32) {
        self.freeCount = v;
    }
}

impl ::protobuf::Message for BindPattern {
    fn is_initialized(&self) -> bool {
        for v in &self.patterns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remainder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patterns)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remainder)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.freeCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patterns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.remainder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.freeCount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.freeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patterns {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.remainder.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.freeCount != 0 {
            os.write_int32(3, self.freeCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BindPattern {
        BindPattern::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "patterns",
                |m: &BindPattern| { &m.patterns },
                |m: &mut BindPattern| { &mut m.patterns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "remainder",
                |m: &BindPattern| { &m.remainder },
                |m: &mut BindPattern| { &mut m.remainder },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "freeCount",
                |m: &BindPattern| { &m.freeCount },
                |m: &mut BindPattern| { &mut m.freeCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BindPattern>(
                "BindPattern",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BindPattern {
        static instance: ::protobuf::rt::LazyV2<BindPattern> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BindPattern::new)
    }
}

impl ::protobuf::Clear for BindPattern {
    fn clear(&mut self) {
        self.patterns.clear();
        self.remainder.clear();
        self.freeCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BindPattern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BindPattern {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBindPatterns {
    // message fields
    pub patterns: ::protobuf::RepeatedField<BindPattern>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBindPatterns {
    fn default() -> &'a ListBindPatterns {
        <ListBindPatterns as ::protobuf::Message>::default_instance()
    }
}

impl ListBindPatterns {
    pub fn new() -> ListBindPatterns {
        ::std::default::Default::default()
    }

    // repeated .BindPattern patterns = 1;


    pub fn get_patterns(&self) -> &[BindPattern] {
        &self.patterns
    }
    pub fn clear_patterns(&mut self) {
        self.patterns.clear();
    }

    // Param is passed by value, moved
    pub fn set_patterns(&mut self, v: ::protobuf::RepeatedField<BindPattern>) {
        self.patterns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patterns(&mut self) -> &mut ::protobuf::RepeatedField<BindPattern> {
        &mut self.patterns
    }

    // Take field
    pub fn take_patterns(&mut self) -> ::protobuf::RepeatedField<BindPattern> {
        ::std::mem::replace(&mut self.patterns, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListBindPatterns {
    fn is_initialized(&self) -> bool {
        for v in &self.patterns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patterns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patterns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patterns {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBindPatterns {
        ListBindPatterns::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BindPattern>>(
                "patterns",
                |m: &ListBindPatterns| { &m.patterns },
                |m: &mut ListBindPatterns| { &mut m.patterns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBindPatterns>(
                "ListBindPatterns",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBindPatterns {
        static instance: ::protobuf::rt::LazyV2<ListBindPatterns> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBindPatterns::new)
    }
}

impl ::protobuf::Clear for ListBindPatterns {
    fn clear(&mut self) {
        self.patterns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBindPatterns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBindPatterns {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Receive {
    // message fields
    pub binds: ::protobuf::RepeatedField<ReceiveBind>,
    pub body: ::protobuf::SingularPtrField<Par>,
    pub persistent: bool,
    pub peek: bool,
    pub bindCount: i32,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Receive {
    fn default() -> &'a Receive {
        <Receive as ::protobuf::Message>::default_instance()
    }
}

impl Receive {
    pub fn new() -> Receive {
        ::std::default::Default::default()
    }

    // repeated .ReceiveBind binds = 1;


    pub fn get_binds(&self) -> &[ReceiveBind] {
        &self.binds
    }
    pub fn clear_binds(&mut self) {
        self.binds.clear();
    }

    // Param is passed by value, moved
    pub fn set_binds(&mut self, v: ::protobuf::RepeatedField<ReceiveBind>) {
        self.binds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binds(&mut self) -> &mut ::protobuf::RepeatedField<ReceiveBind> {
        &mut self.binds
    }

    // Take field
    pub fn take_binds(&mut self) -> ::protobuf::RepeatedField<ReceiveBind> {
        ::std::mem::replace(&mut self.binds, ::protobuf::RepeatedField::new())
    }

    // .Par body = 2;


    pub fn get_body(&self) -> &Par {
        self.body.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Par) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Par {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Par {
        self.body.take().unwrap_or_else(|| Par::new())
    }

    // bool persistent = 3;


    pub fn get_persistent(&self) -> bool {
        self.persistent
    }
    pub fn clear_persistent(&mut self) {
        self.persistent = false;
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: bool) {
        self.persistent = v;
    }

    // bool peek = 4;


    pub fn get_peek(&self) -> bool {
        self.peek
    }
    pub fn clear_peek(&mut self) {
        self.peek = false;
    }

    // Param is passed by value, moved
    pub fn set_peek(&mut self, v: bool) {
        self.peek = v;
    }

    // int32 bindCount = 5;


    pub fn get_bindCount(&self) -> i32 {
        self.bindCount
    }
    pub fn clear_bindCount(&mut self) {
        self.bindCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_bindCount(&mut self, v: i32) {
        self.bindCount = v;
    }

    // bytes locallyFree = 6;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 7;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for Receive {
    fn is_initialized(&self) -> bool {
        for v in &self.binds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binds)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persistent = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.peek = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bindCount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.binds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.persistent != false {
            my_size += 2;
        }
        if self.peek != false {
            my_size += 2;
        }
        if self.bindCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bindCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.binds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.persistent != false {
            os.write_bool(3, self.persistent)?;
        }
        if self.peek != false {
            os.write_bool(4, self.peek)?;
        }
        if self.bindCount != 0 {
            os.write_int32(5, self.bindCount)?;
        }
        if !self.locallyFree.is_empty() {
            os.write_bytes(6, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(7, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Receive {
        Receive::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiveBind>>(
                "binds",
                |m: &Receive| { &m.binds },
                |m: &mut Receive| { &mut m.binds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "body",
                |m: &Receive| { &m.body },
                |m: &mut Receive| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "persistent",
                |m: &Receive| { &m.persistent },
                |m: &mut Receive| { &mut m.persistent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "peek",
                |m: &Receive| { &m.peek },
                |m: &mut Receive| { &mut m.peek },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bindCount",
                |m: &Receive| { &m.bindCount },
                |m: &mut Receive| { &mut m.bindCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &Receive| { &m.locallyFree },
                |m: &mut Receive| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &Receive| { &m.connective_used },
                |m: &mut Receive| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Receive>(
                "Receive",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Receive {
        static instance: ::protobuf::rt::LazyV2<Receive> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Receive::new)
    }
}

impl ::protobuf::Clear for Receive {
    fn clear(&mut self) {
        self.binds.clear();
        self.body.clear();
        self.persistent = false;
        self.peek = false;
        self.bindCount = 0;
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Receive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Receive {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct New {
    // message fields
    pub bindCount: i32,
    pub p: ::protobuf::SingularPtrField<Par>,
    pub uri: ::protobuf::RepeatedField<::std::string::String>,
    pub injections: ::std::collections::HashMap<::std::string::String, Par>,
    pub locallyFree: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a New {
    fn default() -> &'a New {
        <New as ::protobuf::Message>::default_instance()
    }
}

impl New {
    pub fn new() -> New {
        ::std::default::Default::default()
    }

    // sint32 bindCount = 1;


    pub fn get_bindCount(&self) -> i32 {
        self.bindCount
    }
    pub fn clear_bindCount(&mut self) {
        self.bindCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_bindCount(&mut self, v: i32) {
        self.bindCount = v;
    }

    // .Par p = 2;


    pub fn get_p(&self) -> &Par {
        self.p.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p(&mut self) {
        self.p.clear();
    }

    pub fn has_p(&self) -> bool {
        self.p.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p(&mut self, v: Par) {
        self.p = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p(&mut self) -> &mut Par {
        if self.p.is_none() {
            self.p.set_default();
        }
        self.p.as_mut().unwrap()
    }

    // Take field
    pub fn take_p(&mut self) -> Par {
        self.p.take().unwrap_or_else(|| Par::new())
    }

    // repeated string uri = 3;


    pub fn get_uri(&self) -> &[::std::string::String] {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uri, ::protobuf::RepeatedField::new())
    }

    // repeated .New.InjectionsEntry injections = 4;


    pub fn get_injections(&self) -> &::std::collections::HashMap<::std::string::String, Par> {
        &self.injections
    }
    pub fn clear_injections(&mut self) {
        self.injections.clear();
    }

    // Param is passed by value, moved
    pub fn set_injections(&mut self, v: ::std::collections::HashMap<::std::string::String, Par>) {
        self.injections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_injections(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Par> {
        &mut self.injections
    }

    // Take field
    pub fn take_injections(&mut self) -> ::std::collections::HashMap<::std::string::String, Par> {
        ::std::mem::replace(&mut self.injections, ::std::collections::HashMap::new())
    }

    // bytes locallyFree = 5;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for New {
    fn is_initialized(&self) -> bool {
        for v in &self.p {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.bindCount = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uri)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Par>>(wire_type, is, &mut self.injections)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bindCount != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.bindCount);
        }
        if let Some(ref v) = self.p.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.uri {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Par>>(4, &self.injections);
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.locallyFree);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bindCount != 0 {
            os.write_sint32(1, self.bindCount)?;
        }
        if let Some(ref v) = self.p.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.uri {
            os.write_string(3, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Par>>(4, &self.injections, os)?;
        if !self.locallyFree.is_empty() {
            os.write_bytes(5, &self.locallyFree)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> New {
        New::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "bindCount",
                |m: &New| { &m.bindCount },
                |m: &mut New| { &mut m.bindCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p",
                |m: &New| { &m.p },
                |m: &mut New| { &mut m.p },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &New| { &m.uri },
                |m: &mut New| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "injections",
                |m: &New| { &m.injections },
                |m: &mut New| { &mut m.injections },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &New| { &m.locallyFree },
                |m: &mut New| { &mut m.locallyFree },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<New>(
                "New",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static New {
        static instance: ::protobuf::rt::LazyV2<New> = ::protobuf::rt::LazyV2::INIT;
        instance.get(New::new)
    }
}

impl ::protobuf::Clear for New {
    fn clear(&mut self) {
        self.bindCount = 0;
        self.p.clear();
        self.uri.clear();
        self.injections.clear();
        self.locallyFree.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for New {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for New {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchCase {
    // message fields
    pub pattern: ::protobuf::SingularPtrField<Par>,
    pub source: ::protobuf::SingularPtrField<Par>,
    pub freeCount: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MatchCase {
    fn default() -> &'a MatchCase {
        <MatchCase as ::protobuf::Message>::default_instance()
    }
}

impl MatchCase {
    pub fn new() -> MatchCase {
        ::std::default::Default::default()
    }

    // .Par pattern = 1;


    pub fn get_pattern(&self) -> &Par {
        self.pattern.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pattern(&mut self) {
        self.pattern.clear();
    }

    pub fn has_pattern(&self) -> bool {
        self.pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: Par) {
        self.pattern = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pattern(&mut self) -> &mut Par {
        if self.pattern.is_none() {
            self.pattern.set_default();
        }
        self.pattern.as_mut().unwrap()
    }

    // Take field
    pub fn take_pattern(&mut self) -> Par {
        self.pattern.take().unwrap_or_else(|| Par::new())
    }

    // .Par source = 2;


    pub fn get_source(&self) -> &Par {
        self.source.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Par) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Par {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Par {
        self.source.take().unwrap_or_else(|| Par::new())
    }

    // int32 freeCount = 3;


    pub fn get_freeCount(&self) -> i32 {
        self.freeCount
    }
    pub fn clear_freeCount(&mut self) {
        self.freeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeCount(&mut self, v: i32) {
        self.freeCount = v;
    }
}

impl ::protobuf::Message for MatchCase {
    fn is_initialized(&self) -> bool {
        for v in &self.pattern {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pattern)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.freeCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pattern.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.freeCount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.freeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pattern.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.freeCount != 0 {
            os.write_int32(3, self.freeCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchCase {
        MatchCase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "pattern",
                |m: &MatchCase| { &m.pattern },
                |m: &mut MatchCase| { &mut m.pattern },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "source",
                |m: &MatchCase| { &m.source },
                |m: &mut MatchCase| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "freeCount",
                |m: &MatchCase| { &m.freeCount },
                |m: &mut MatchCase| { &mut m.freeCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MatchCase>(
                "MatchCase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MatchCase {
        static instance: ::protobuf::rt::LazyV2<MatchCase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MatchCase::new)
    }
}

impl ::protobuf::Clear for MatchCase {
    fn clear(&mut self) {
        self.pattern.clear();
        self.source.clear();
        self.freeCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchCase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchCase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Match {
    // message fields
    pub target: ::protobuf::SingularPtrField<Par>,
    pub cases: ::protobuf::RepeatedField<MatchCase>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Match {
    fn default() -> &'a Match {
        <Match as ::protobuf::Message>::default_instance()
    }
}

impl Match {
    pub fn new() -> Match {
        ::std::default::Default::default()
    }

    // .Par target = 1;


    pub fn get_target(&self) -> &Par {
        self.target.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Par) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Par {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Par {
        self.target.take().unwrap_or_else(|| Par::new())
    }

    // repeated .MatchCase cases = 2;


    pub fn get_cases(&self) -> &[MatchCase] {
        &self.cases
    }
    pub fn clear_cases(&mut self) {
        self.cases.clear();
    }

    // Param is passed by value, moved
    pub fn set_cases(&mut self, v: ::protobuf::RepeatedField<MatchCase>) {
        self.cases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cases(&mut self) -> &mut ::protobuf::RepeatedField<MatchCase> {
        &mut self.cases
    }

    // Take field
    pub fn take_cases(&mut self) -> ::protobuf::RepeatedField<MatchCase> {
        ::std::mem::replace(&mut self.cases, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 4;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 5;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for Match {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cases)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.cases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.cases {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(4, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(5, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Match {
        Match::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "target",
                |m: &Match| { &m.target },
                |m: &mut Match| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchCase>>(
                "cases",
                |m: &Match| { &m.cases },
                |m: &mut Match| { &mut m.cases },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &Match| { &m.locallyFree },
                |m: &mut Match| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &Match| { &m.connective_used },
                |m: &mut Match| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Match>(
                "Match",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Match {
        static instance: ::protobuf::rt::LazyV2<Match> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Match::new)
    }
}

impl ::protobuf::Clear for Match {
    fn clear(&mut self) {
        self.target.clear();
        self.cases.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Match {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr {
    // message oneof groups
    pub expr_instance: ::std::option::Option<Expr_oneof_expr_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr {
    fn default() -> &'a Expr {
        <Expr as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Expr_oneof_expr_instance {
    g_bool(bool),
    g_int(i64),
    g_string(::std::string::String),
    g_uri(::std::string::String),
    g_byte_array(::bytes::Bytes),
    e_not_body(ENot),
    e_neg_body(ENeg),
    e_mult_body(EMult),
    e_div_body(EDiv),
    e_plus_body(EPlus),
    e_minus_body(EMinus),
    e_lt_body(ELt),
    e_lte_body(ELte),
    e_gt_body(EGt),
    e_gte_body(EGte),
    e_eq_body(EEq),
    e_neq_body(ENeq),
    e_and_body(EAnd),
    e_or_body(EOr),
    e_var_body(EVar),
    e_list_body(EList),
    e_tuple_body(ETuple),
    e_set_body(ESet),
    e_map_body(EMap),
    e_method_body(EMethod),
    e_matches_body(EMatches),
    e_percent_percent_body(EPercentPercent),
    e_plus_plus_body(EPlusPlus),
    e_minus_minus_body(EMinusMinus),
    e_mod_body(EMod),
}

impl Expr {
    pub fn new() -> Expr {
        ::std::default::Default::default()
    }

    // bool g_bool = 1;


    pub fn get_g_bool(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_bool(v)) => v,
            _ => false,
        }
    }
    pub fn clear_g_bool(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_g_bool(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_bool(&mut self, v: bool) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_bool(v))
    }

    // sint64 g_int = 2;


    pub fn get_g_int(&self) -> i64 {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_int(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_g_int(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_g_int(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_int(&mut self, v: i64) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_int(v))
    }

    // string g_string = 3;


    pub fn get_g_string(&self) -> &str {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_g_string(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_g_string(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_string(&mut self, v: ::std::string::String) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(::std::string::String::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_string(&mut self) -> ::std::string::String {
        if self.has_g_string() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string g_uri = 4;


    pub fn get_g_uri(&self) -> &str {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_g_uri(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_g_uri(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_uri(&mut self, v: ::std::string::String) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_uri(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(::std::string::String::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_uri(&mut self) -> ::std::string::String {
        if self.has_g_uri() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes g_byte_array = 25;


    pub fn get_g_byte_array(&self) -> &[u8] {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_g_byte_array(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_g_byte_array(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_byte_array(&mut self, v: ::bytes::Bytes) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_byte_array(&mut self) -> &mut ::bytes::Bytes {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(::bytes::Bytes::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_byte_array(&mut self) -> ::bytes::Bytes {
        if self.has_g_byte_array() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(v)) => v,
                _ => panic!(),
            }
        } else {
            ::bytes::Bytes::new()
        }
    }

    // .ENot e_not_body = 5;


    pub fn get_e_not_body(&self) -> &ENot {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(ref v)) => v,
            _ => <ENot as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_not_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_not_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_not_body(&mut self, v: ENot) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_not_body(&mut self) -> &mut ENot {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(ENot::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_not_body(&mut self) -> ENot {
        if self.has_e_not_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ENot::new()
        }
    }

    // .ENeg e_neg_body = 6;


    pub fn get_e_neg_body(&self) -> &ENeg {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(ref v)) => v,
            _ => <ENeg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_neg_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_neg_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_neg_body(&mut self, v: ENeg) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_neg_body(&mut self) -> &mut ENeg {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(ENeg::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_neg_body(&mut self) -> ENeg {
        if self.has_e_neg_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ENeg::new()
        }
    }

    // .EMult e_mult_body = 7;


    pub fn get_e_mult_body(&self) -> &EMult {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(ref v)) => v,
            _ => <EMult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_mult_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_mult_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_mult_body(&mut self, v: EMult) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_mult_body(&mut self) -> &mut EMult {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(EMult::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_mult_body(&mut self) -> EMult {
        if self.has_e_mult_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMult::new()
        }
    }

    // .EDiv e_div_body = 8;


    pub fn get_e_div_body(&self) -> &EDiv {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(ref v)) => v,
            _ => <EDiv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_div_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_div_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_div_body(&mut self, v: EDiv) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_div_body(&mut self) -> &mut EDiv {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(EDiv::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_div_body(&mut self) -> EDiv {
        if self.has_e_div_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EDiv::new()
        }
    }

    // .EPlus e_plus_body = 9;


    pub fn get_e_plus_body(&self) -> &EPlus {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(ref v)) => v,
            _ => <EPlus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_plus_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_plus_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_plus_body(&mut self, v: EPlus) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_plus_body(&mut self) -> &mut EPlus {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(EPlus::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_plus_body(&mut self) -> EPlus {
        if self.has_e_plus_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EPlus::new()
        }
    }

    // .EMinus e_minus_body = 10;


    pub fn get_e_minus_body(&self) -> &EMinus {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(ref v)) => v,
            _ => <EMinus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_minus_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_minus_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_minus_body(&mut self, v: EMinus) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_minus_body(&mut self) -> &mut EMinus {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(EMinus::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_minus_body(&mut self) -> EMinus {
        if self.has_e_minus_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMinus::new()
        }
    }

    // .ELt e_lt_body = 11;


    pub fn get_e_lt_body(&self) -> &ELt {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(ref v)) => v,
            _ => <ELt as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_lt_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_lt_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_lt_body(&mut self, v: ELt) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_lt_body(&mut self) -> &mut ELt {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(ELt::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_lt_body(&mut self) -> ELt {
        if self.has_e_lt_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ELt::new()
        }
    }

    // .ELte e_lte_body = 12;


    pub fn get_e_lte_body(&self) -> &ELte {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(ref v)) => v,
            _ => <ELte as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_lte_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_lte_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_lte_body(&mut self, v: ELte) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_lte_body(&mut self) -> &mut ELte {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(ELte::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_lte_body(&mut self) -> ELte {
        if self.has_e_lte_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ELte::new()
        }
    }

    // .EGt e_gt_body = 13;


    pub fn get_e_gt_body(&self) -> &EGt {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(ref v)) => v,
            _ => <EGt as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_gt_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_gt_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_gt_body(&mut self, v: EGt) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_gt_body(&mut self) -> &mut EGt {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(EGt::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_gt_body(&mut self) -> EGt {
        if self.has_e_gt_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EGt::new()
        }
    }

    // .EGte e_gte_body = 14;


    pub fn get_e_gte_body(&self) -> &EGte {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(ref v)) => v,
            _ => <EGte as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_gte_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_gte_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_gte_body(&mut self, v: EGte) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_gte_body(&mut self) -> &mut EGte {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(EGte::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_gte_body(&mut self) -> EGte {
        if self.has_e_gte_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EGte::new()
        }
    }

    // .EEq e_eq_body = 15;


    pub fn get_e_eq_body(&self) -> &EEq {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(ref v)) => v,
            _ => <EEq as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_eq_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_eq_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_eq_body(&mut self, v: EEq) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_eq_body(&mut self) -> &mut EEq {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(EEq::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_eq_body(&mut self) -> EEq {
        if self.has_e_eq_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EEq::new()
        }
    }

    // .ENeq e_neq_body = 16;


    pub fn get_e_neq_body(&self) -> &ENeq {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(ref v)) => v,
            _ => <ENeq as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_neq_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_neq_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_neq_body(&mut self, v: ENeq) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_neq_body(&mut self) -> &mut ENeq {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(ENeq::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_neq_body(&mut self) -> ENeq {
        if self.has_e_neq_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ENeq::new()
        }
    }

    // .EAnd e_and_body = 17;


    pub fn get_e_and_body(&self) -> &EAnd {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(ref v)) => v,
            _ => <EAnd as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_and_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_and_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_and_body(&mut self, v: EAnd) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_and_body(&mut self) -> &mut EAnd {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(EAnd::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_and_body(&mut self) -> EAnd {
        if self.has_e_and_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EAnd::new()
        }
    }

    // .EOr e_or_body = 18;


    pub fn get_e_or_body(&self) -> &EOr {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(ref v)) => v,
            _ => <EOr as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_or_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_or_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_or_body(&mut self, v: EOr) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_or_body(&mut self) -> &mut EOr {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(EOr::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_or_body(&mut self) -> EOr {
        if self.has_e_or_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EOr::new()
        }
    }

    // .EVar e_var_body = 19;


    pub fn get_e_var_body(&self) -> &EVar {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(ref v)) => v,
            _ => <EVar as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_var_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_var_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_var_body(&mut self, v: EVar) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_var_body(&mut self) -> &mut EVar {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(EVar::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_var_body(&mut self) -> EVar {
        if self.has_e_var_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EVar::new()
        }
    }

    // .EList e_list_body = 20;


    pub fn get_e_list_body(&self) -> &EList {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(ref v)) => v,
            _ => <EList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_list_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_list_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_list_body(&mut self, v: EList) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_list_body(&mut self) -> &mut EList {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(EList::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_list_body(&mut self) -> EList {
        if self.has_e_list_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EList::new()
        }
    }

    // .ETuple e_tuple_body = 21;


    pub fn get_e_tuple_body(&self) -> &ETuple {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(ref v)) => v,
            _ => <ETuple as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_tuple_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_tuple_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_tuple_body(&mut self, v: ETuple) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_tuple_body(&mut self) -> &mut ETuple {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(ETuple::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_tuple_body(&mut self) -> ETuple {
        if self.has_e_tuple_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ETuple::new()
        }
    }

    // .ESet e_set_body = 22;


    pub fn get_e_set_body(&self) -> &ESet {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(ref v)) => v,
            _ => <ESet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_set_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_set_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_set_body(&mut self, v: ESet) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_set_body(&mut self) -> &mut ESet {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(ESet::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_set_body(&mut self) -> ESet {
        if self.has_e_set_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ESet::new()
        }
    }

    // .EMap e_map_body = 23;


    pub fn get_e_map_body(&self) -> &EMap {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(ref v)) => v,
            _ => <EMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_map_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_map_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_map_body(&mut self, v: EMap) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_map_body(&mut self) -> &mut EMap {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(EMap::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_map_body(&mut self) -> EMap {
        if self.has_e_map_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMap::new()
        }
    }

    // .EMethod e_method_body = 24;


    pub fn get_e_method_body(&self) -> &EMethod {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(ref v)) => v,
            _ => <EMethod as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_method_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_method_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_method_body(&mut self, v: EMethod) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_method_body(&mut self) -> &mut EMethod {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(EMethod::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_method_body(&mut self) -> EMethod {
        if self.has_e_method_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMethod::new()
        }
    }

    // .EMatches e_matches_body = 27;


    pub fn get_e_matches_body(&self) -> &EMatches {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(ref v)) => v,
            _ => <EMatches as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_matches_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_matches_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_matches_body(&mut self, v: EMatches) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_matches_body(&mut self) -> &mut EMatches {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(EMatches::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_matches_body(&mut self) -> EMatches {
        if self.has_e_matches_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMatches::new()
        }
    }

    // .EPercentPercent e_percent_percent_body = 28;


    pub fn get_e_percent_percent_body(&self) -> &EPercentPercent {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(ref v)) => v,
            _ => <EPercentPercent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_percent_percent_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_percent_percent_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_percent_percent_body(&mut self, v: EPercentPercent) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_percent_percent_body(&mut self) -> &mut EPercentPercent {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(EPercentPercent::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_percent_percent_body(&mut self) -> EPercentPercent {
        if self.has_e_percent_percent_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EPercentPercent::new()
        }
    }

    // .EPlusPlus e_plus_plus_body = 29;


    pub fn get_e_plus_plus_body(&self) -> &EPlusPlus {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(ref v)) => v,
            _ => <EPlusPlus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_plus_plus_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_plus_plus_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_plus_plus_body(&mut self, v: EPlusPlus) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_plus_plus_body(&mut self) -> &mut EPlusPlus {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(EPlusPlus::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_plus_plus_body(&mut self) -> EPlusPlus {
        if self.has_e_plus_plus_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EPlusPlus::new()
        }
    }

    // .EMinusMinus e_minus_minus_body = 30;


    pub fn get_e_minus_minus_body(&self) -> &EMinusMinus {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(ref v)) => v,
            _ => <EMinusMinus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_minus_minus_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_minus_minus_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_minus_minus_body(&mut self, v: EMinusMinus) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_minus_minus_body(&mut self) -> &mut EMinusMinus {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(EMinusMinus::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_minus_minus_body(&mut self) -> EMinusMinus {
        if self.has_e_minus_minus_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMinusMinus::new()
        }
    }

    // .EMod e_mod_body = 31;


    pub fn get_e_mod_body(&self) -> &EMod {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(ref v)) => v,
            _ => <EMod as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_e_mod_body(&mut self) {
        self.expr_instance = ::std::option::Option::None;
    }

    pub fn has_e_mod_body(&self) -> bool {
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_e_mod_body(&mut self, v: EMod) {
        self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_e_mod_body(&mut self) -> &mut EMod {
        if let ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(_)) = self.expr_instance {
        } else {
            self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(EMod::new()));
        }
        match self.expr_instance {
            ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_e_mod_body(&mut self) -> EMod {
        if self.has_e_mod_body() {
            match self.expr_instance.take() {
                ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(v)) => v,
                _ => panic!(),
            }
        } else {
            EMod::new()
        }
    }
}

impl ::protobuf::Message for Expr {
    fn is_initialized(&self) -> bool {
        if let Some(Expr_oneof_expr_instance::e_not_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_neg_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_mult_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_div_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_plus_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_minus_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_lt_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_lte_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_gt_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_gte_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_eq_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_neq_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_and_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_or_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_var_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_list_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_tuple_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_set_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_map_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_method_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_matches_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_percent_percent_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_plus_plus_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_minus_minus_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_expr_instance::e_mod_body(ref v)) = self.expr_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_bool(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_int(is.read_sint64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_string(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_uri(is.read_string()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::g_byte_array(is.read_carllerche_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_not_body(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neg_body(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mult_body(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_div_body(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_body(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_body(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lt_body(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_lte_body(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gt_body(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_gte_body(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_eq_body(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_neq_body(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_and_body(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_or_body(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_var_body(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_list_body(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_tuple_body(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_set_body(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_map_body(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_method_body(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_matches_body(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_percent_percent_body(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_plus_plus_body(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_minus_minus_body(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expr_instance = ::std::option::Option::Some(Expr_oneof_expr_instance::e_mod_body(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.expr_instance {
            match v {
                &Expr_oneof_expr_instance::g_bool(v) => {
                    my_size += 2;
                },
                &Expr_oneof_expr_instance::g_int(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
                },
                &Expr_oneof_expr_instance::g_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &Expr_oneof_expr_instance::g_uri(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &Expr_oneof_expr_instance::g_byte_array(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(25, &v);
                },
                &Expr_oneof_expr_instance::e_not_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_neg_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_mult_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_div_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_plus_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_minus_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_lt_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_lte_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_gt_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_gte_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_eq_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_neq_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_and_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_or_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_var_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_list_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_tuple_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_set_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_map_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_method_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_matches_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_percent_percent_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_plus_plus_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_minus_minus_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_expr_instance::e_mod_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.expr_instance {
            match v {
                &Expr_oneof_expr_instance::g_bool(v) => {
                    os.write_bool(1, v)?;
                },
                &Expr_oneof_expr_instance::g_int(v) => {
                    os.write_sint64(2, v)?;
                },
                &Expr_oneof_expr_instance::g_string(ref v) => {
                    os.write_string(3, v)?;
                },
                &Expr_oneof_expr_instance::g_uri(ref v) => {
                    os.write_string(4, v)?;
                },
                &Expr_oneof_expr_instance::g_byte_array(ref v) => {
                    os.write_bytes(25, v)?;
                },
                &Expr_oneof_expr_instance::e_not_body(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_neg_body(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_mult_body(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_div_body(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_plus_body(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_minus_body(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_lt_body(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_lte_body(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_gt_body(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_gte_body(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_eq_body(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_neq_body(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_and_body(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_or_body(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_var_body(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_list_body(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_tuple_body(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_set_body(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_map_body(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_method_body(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_matches_body(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_percent_percent_body(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_plus_plus_body(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_minus_minus_body(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_expr_instance::e_mod_body(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr {
        Expr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "g_bool",
                Expr::has_g_bool,
                Expr::get_g_bool,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "g_int",
                Expr::has_g_int,
                Expr::get_g_int,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "g_string",
                Expr::has_g_string,
                Expr::get_g_string,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "g_uri",
                Expr::has_g_uri,
                Expr::get_g_uri,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "g_byte_array",
                Expr::has_g_byte_array,
                Expr::get_g_byte_array,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ENot>(
                "e_not_body",
                Expr::has_e_not_body,
                Expr::get_e_not_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ENeg>(
                "e_neg_body",
                Expr::has_e_neg_body,
                Expr::get_e_neg_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMult>(
                "e_mult_body",
                Expr::has_e_mult_body,
                Expr::get_e_mult_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EDiv>(
                "e_div_body",
                Expr::has_e_div_body,
                Expr::get_e_div_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EPlus>(
                "e_plus_body",
                Expr::has_e_plus_body,
                Expr::get_e_plus_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMinus>(
                "e_minus_body",
                Expr::has_e_minus_body,
                Expr::get_e_minus_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ELt>(
                "e_lt_body",
                Expr::has_e_lt_body,
                Expr::get_e_lt_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ELte>(
                "e_lte_body",
                Expr::has_e_lte_body,
                Expr::get_e_lte_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EGt>(
                "e_gt_body",
                Expr::has_e_gt_body,
                Expr::get_e_gt_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EGte>(
                "e_gte_body",
                Expr::has_e_gte_body,
                Expr::get_e_gte_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EEq>(
                "e_eq_body",
                Expr::has_e_eq_body,
                Expr::get_e_eq_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ENeq>(
                "e_neq_body",
                Expr::has_e_neq_body,
                Expr::get_e_neq_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EAnd>(
                "e_and_body",
                Expr::has_e_and_body,
                Expr::get_e_and_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EOr>(
                "e_or_body",
                Expr::has_e_or_body,
                Expr::get_e_or_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EVar>(
                "e_var_body",
                Expr::has_e_var_body,
                Expr::get_e_var_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EList>(
                "e_list_body",
                Expr::has_e_list_body,
                Expr::get_e_list_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ETuple>(
                "e_tuple_body",
                Expr::has_e_tuple_body,
                Expr::get_e_tuple_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ESet>(
                "e_set_body",
                Expr::has_e_set_body,
                Expr::get_e_set_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMap>(
                "e_map_body",
                Expr::has_e_map_body,
                Expr::get_e_map_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMethod>(
                "e_method_body",
                Expr::has_e_method_body,
                Expr::get_e_method_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMatches>(
                "e_matches_body",
                Expr::has_e_matches_body,
                Expr::get_e_matches_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EPercentPercent>(
                "e_percent_percent_body",
                Expr::has_e_percent_percent_body,
                Expr::get_e_percent_percent_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EPlusPlus>(
                "e_plus_plus_body",
                Expr::has_e_plus_plus_body,
                Expr::get_e_plus_plus_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMinusMinus>(
                "e_minus_minus_body",
                Expr::has_e_minus_minus_body,
                Expr::get_e_minus_minus_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EMod>(
                "e_mod_body",
                Expr::has_e_mod_body,
                Expr::get_e_mod_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Expr>(
                "Expr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Expr {
        static instance: ::protobuf::rt::LazyV2<Expr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Expr::new)
    }
}

impl ::protobuf::Clear for Expr {
    fn clear(&mut self) {
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.expr_instance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EList {
    // message fields
    pub ps: ::protobuf::RepeatedField<Par>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    pub remainder: ::protobuf::SingularPtrField<Var>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EList {
    fn default() -> &'a EList {
        <EList as ::protobuf::Message>::default_instance()
    }
}

impl EList {
    pub fn new() -> EList {
        ::std::default::Default::default()
    }

    // repeated .Par ps = 1;


    pub fn get_ps(&self) -> &[Par] {
        &self.ps
    }
    pub fn clear_ps(&mut self) {
        self.ps.clear();
    }

    // Param is passed by value, moved
    pub fn set_ps(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.ps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ps(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.ps
    }

    // Take field
    pub fn take_ps(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.ps, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 3;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 4;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }

    // .Var remainder = 5;


    pub fn get_remainder(&self) -> &Var {
        self.remainder.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remainder(&mut self) {
        self.remainder.clear();
    }

    pub fn has_remainder(&self) -> bool {
        self.remainder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainder(&mut self, v: Var) {
        self.remainder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remainder(&mut self) -> &mut Var {
        if self.remainder.is_none() {
            self.remainder.set_default();
        }
        self.remainder.as_mut().unwrap()
    }

    // Take field
    pub fn take_remainder(&mut self) -> Var {
        self.remainder.take().unwrap_or_else(|| Var::new())
    }
}

impl ::protobuf::Message for EList {
    fn is_initialized(&self) -> bool {
        for v in &self.ps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remainder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remainder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(3, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(4, self.connective_used)?;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EList {
        EList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "ps",
                |m: &EList| { &m.ps },
                |m: &mut EList| { &mut m.ps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &EList| { &m.locallyFree },
                |m: &mut EList| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &EList| { &m.connective_used },
                |m: &mut EList| { &mut m.connective_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "remainder",
                |m: &EList| { &m.remainder },
                |m: &mut EList| { &mut m.remainder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EList>(
                "EList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EList {
        static instance: ::protobuf::rt::LazyV2<EList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EList::new)
    }
}

impl ::protobuf::Clear for EList {
    fn clear(&mut self) {
        self.ps.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.remainder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ETuple {
    // message fields
    pub ps: ::protobuf::RepeatedField<Par>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ETuple {
    fn default() -> &'a ETuple {
        <ETuple as ::protobuf::Message>::default_instance()
    }
}

impl ETuple {
    pub fn new() -> ETuple {
        ::std::default::Default::default()
    }

    // repeated .Par ps = 1;


    pub fn get_ps(&self) -> &[Par] {
        &self.ps
    }
    pub fn clear_ps(&mut self) {
        self.ps.clear();
    }

    // Param is passed by value, moved
    pub fn set_ps(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.ps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ps(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.ps
    }

    // Take field
    pub fn take_ps(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.ps, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 3;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 4;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for ETuple {
    fn is_initialized(&self) -> bool {
        for v in &self.ps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(3, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(4, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ETuple {
        ETuple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "ps",
                |m: &ETuple| { &m.ps },
                |m: &mut ETuple| { &mut m.ps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &ETuple| { &m.locallyFree },
                |m: &mut ETuple| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &ETuple| { &m.connective_used },
                |m: &mut ETuple| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ETuple>(
                "ETuple",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ETuple {
        static instance: ::protobuf::rt::LazyV2<ETuple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ETuple::new)
    }
}

impl ::protobuf::Clear for ETuple {
    fn clear(&mut self) {
        self.ps.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ETuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ETuple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ESet {
    // message fields
    pub ps: ::protobuf::RepeatedField<Par>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    pub remainder: ::protobuf::SingularPtrField<Var>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESet {
    fn default() -> &'a ESet {
        <ESet as ::protobuf::Message>::default_instance()
    }
}

impl ESet {
    pub fn new() -> ESet {
        ::std::default::Default::default()
    }

    // repeated .Par ps = 1;


    pub fn get_ps(&self) -> &[Par] {
        &self.ps
    }
    pub fn clear_ps(&mut self) {
        self.ps.clear();
    }

    // Param is passed by value, moved
    pub fn set_ps(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.ps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ps(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.ps
    }

    // Take field
    pub fn take_ps(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.ps, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 3;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 4;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }

    // .Var remainder = 5;


    pub fn get_remainder(&self) -> &Var {
        self.remainder.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remainder(&mut self) {
        self.remainder.clear();
    }

    pub fn has_remainder(&self) -> bool {
        self.remainder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainder(&mut self, v: Var) {
        self.remainder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remainder(&mut self) -> &mut Var {
        if self.remainder.is_none() {
            self.remainder.set_default();
        }
        self.remainder.as_mut().unwrap()
    }

    // Take field
    pub fn take_remainder(&mut self) -> Var {
        self.remainder.take().unwrap_or_else(|| Var::new())
    }
}

impl ::protobuf::Message for ESet {
    fn is_initialized(&self) -> bool {
        for v in &self.ps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remainder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remainder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(3, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(4, self.connective_used)?;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESet {
        ESet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "ps",
                |m: &ESet| { &m.ps },
                |m: &mut ESet| { &mut m.ps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &ESet| { &m.locallyFree },
                |m: &mut ESet| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &ESet| { &m.connective_used },
                |m: &mut ESet| { &mut m.connective_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "remainder",
                |m: &ESet| { &m.remainder },
                |m: &mut ESet| { &mut m.remainder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESet>(
                "ESet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESet {
        static instance: ::protobuf::rt::LazyV2<ESet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESet::new)
    }
}

impl ::protobuf::Clear for ESet {
    fn clear(&mut self) {
        self.ps.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.remainder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMap {
    // message fields
    pub kvs: ::protobuf::RepeatedField<KeyValuePair>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    pub remainder: ::protobuf::SingularPtrField<Var>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMap {
    fn default() -> &'a EMap {
        <EMap as ::protobuf::Message>::default_instance()
    }
}

impl EMap {
    pub fn new() -> EMap {
        ::std::default::Default::default()
    }

    // repeated .KeyValuePair kvs = 1;


    pub fn get_kvs(&self) -> &[KeyValuePair] {
        &self.kvs
    }
    pub fn clear_kvs(&mut self) {
        self.kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvs(&mut self, v: ::protobuf::RepeatedField<KeyValuePair>) {
        self.kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvs(&mut self) -> &mut ::protobuf::RepeatedField<KeyValuePair> {
        &mut self.kvs
    }

    // Take field
    pub fn take_kvs(&mut self) -> ::protobuf::RepeatedField<KeyValuePair> {
        ::std::mem::replace(&mut self.kvs, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 3;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 4;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }

    // .Var remainder = 5;


    pub fn get_remainder(&self) -> &Var {
        self.remainder.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remainder(&mut self) {
        self.remainder.clear();
    }

    pub fn has_remainder(&self) -> bool {
        self.remainder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainder(&mut self, v: Var) {
        self.remainder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remainder(&mut self) -> &mut Var {
        if self.remainder.is_none() {
            self.remainder.set_default();
        }
        self.remainder.as_mut().unwrap()
    }

    // Take field
    pub fn take_remainder(&mut self) -> Var {
        self.remainder.take().unwrap_or_else(|| Var::new())
    }
}

impl ::protobuf::Message for EMap {
    fn is_initialized(&self) -> bool {
        for v in &self.kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remainder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remainder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kvs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(3, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(4, self.connective_used)?;
        }
        if let Some(ref v) = self.remainder.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMap {
        EMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValuePair>>(
                "kvs",
                |m: &EMap| { &m.kvs },
                |m: &mut EMap| { &mut m.kvs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &EMap| { &m.locallyFree },
                |m: &mut EMap| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &EMap| { &m.connective_used },
                |m: &mut EMap| { &mut m.connective_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "remainder",
                |m: &EMap| { &m.remainder },
                |m: &mut EMap| { &mut m.remainder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMap>(
                "EMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMap {
        static instance: ::protobuf::rt::LazyV2<EMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMap::new)
    }
}

impl ::protobuf::Clear for EMap {
    fn clear(&mut self) {
        self.kvs.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.remainder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMethod {
    // message fields
    pub methodName: ::std::string::String,
    pub target: ::protobuf::SingularPtrField<Par>,
    pub arguments: ::protobuf::RepeatedField<Par>,
    pub locallyFree: ::bytes::Bytes,
    pub connective_used: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMethod {
    fn default() -> &'a EMethod {
        <EMethod as ::protobuf::Message>::default_instance()
    }
}

impl EMethod {
    pub fn new() -> EMethod {
        ::std::default::Default::default()
    }

    // string methodName = 1;


    pub fn get_methodName(&self) -> &str {
        &self.methodName
    }
    pub fn clear_methodName(&mut self) {
        self.methodName.clear();
    }

    // Param is passed by value, moved
    pub fn set_methodName(&mut self, v: ::std::string::String) {
        self.methodName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_methodName(&mut self) -> &mut ::std::string::String {
        &mut self.methodName
    }

    // Take field
    pub fn take_methodName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.methodName, ::std::string::String::new())
    }

    // .Par target = 2;


    pub fn get_target(&self) -> &Par {
        self.target.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Par) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Par {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Par {
        self.target.take().unwrap_or_else(|| Par::new())
    }

    // repeated .Par arguments = 3;


    pub fn get_arguments(&self) -> &[Par] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    // bytes locallyFree = 5;


    pub fn get_locallyFree(&self) -> &[u8] {
        &self.locallyFree
    }
    pub fn clear_locallyFree(&mut self) {
        self.locallyFree.clear();
    }

    // Param is passed by value, moved
    pub fn set_locallyFree(&mut self, v: ::bytes::Bytes) {
        self.locallyFree = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locallyFree(&mut self) -> &mut ::bytes::Bytes {
        &mut self.locallyFree
    }

    // Take field
    pub fn take_locallyFree(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.locallyFree, ::bytes::Bytes::new())
    }

    // bool connective_used = 6;


    pub fn get_connective_used(&self) -> bool {
        self.connective_used
    }
    pub fn clear_connective_used(&mut self) {
        self.connective_used = false;
    }

    // Param is passed by value, moved
    pub fn set_connective_used(&mut self, v: bool) {
        self.connective_used = v;
    }
}

impl ::protobuf::Message for EMethod {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.methodName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.locallyFree)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connective_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.methodName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.methodName);
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.locallyFree.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.locallyFree);
        }
        if self.connective_used != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.methodName.is_empty() {
            os.write_string(1, &self.methodName)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arguments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.locallyFree.is_empty() {
            os.write_bytes(5, &self.locallyFree)?;
        }
        if self.connective_used != false {
            os.write_bool(6, self.connective_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMethod {
        EMethod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "methodName",
                |m: &EMethod| { &m.methodName },
                |m: &mut EMethod| { &mut m.methodName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "target",
                |m: &EMethod| { &m.target },
                |m: &mut EMethod| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "arguments",
                |m: &EMethod| { &m.arguments },
                |m: &mut EMethod| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "locallyFree",
                |m: &EMethod| { &m.locallyFree },
                |m: &mut EMethod| { &mut m.locallyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "connective_used",
                |m: &EMethod| { &m.connective_used },
                |m: &mut EMethod| { &mut m.connective_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMethod>(
                "EMethod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMethod {
        static instance: ::protobuf::rt::LazyV2<EMethod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMethod::new)
    }
}

impl ::protobuf::Clear for EMethod {
    fn clear(&mut self) {
        self.methodName.clear();
        self.target.clear();
        self.arguments.clear();
        self.locallyFree.clear();
        self.connective_used = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValuePair {
    // message fields
    pub key: ::protobuf::SingularPtrField<Par>,
    pub value: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    // .Par key = 1;


    pub fn get_key(&self) -> &Par {
        self.key.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Par) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Par {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Par {
        self.key.take().unwrap_or_else(|| Par::new())
    }

    // .Par value = 2;


    pub fn get_value(&self) -> &Par {
        self.value.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Par) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Par {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Par {
        self.value.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for KeyValuePair {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "key",
                |m: &KeyValuePair| { &m.key },
                |m: &mut KeyValuePair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "value",
                |m: &KeyValuePair| { &m.value },
                |m: &mut KeyValuePair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValuePair>(
                "KeyValuePair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: ::protobuf::rt::LazyV2<KeyValuePair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValuePair::new)
    }
}

impl ::protobuf::Clear for KeyValuePair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVar {
    // message fields
    pub v: ::protobuf::SingularPtrField<Var>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVar {
    fn default() -> &'a EVar {
        <EVar as ::protobuf::Message>::default_instance()
    }
}

impl EVar {
    pub fn new() -> EVar {
        ::std::default::Default::default()
    }

    // .Var v = 1;


    pub fn get_v(&self) -> &Var {
        self.v.as_ref().unwrap_or_else(|| <Var as ::protobuf::Message>::default_instance())
    }
    pub fn clear_v(&mut self) {
        self.v.clear();
    }

    pub fn has_v(&self) -> bool {
        self.v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v(&mut self, v: Var) {
        self.v = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_v(&mut self) -> &mut Var {
        if self.v.is_none() {
            self.v.set_default();
        }
        self.v.as_mut().unwrap()
    }

    // Take field
    pub fn take_v(&mut self) -> Var {
        self.v.take().unwrap_or_else(|| Var::new())
    }
}

impl ::protobuf::Message for EVar {
    fn is_initialized(&self) -> bool {
        for v in &self.v {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.v)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.v.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVar {
        EVar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Var>>(
                "v",
                |m: &EVar| { &m.v },
                |m: &mut EVar| { &mut m.v },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EVar>(
                "EVar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EVar {
        static instance: ::protobuf::rt::LazyV2<EVar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EVar::new)
    }
}

impl ::protobuf::Clear for EVar {
    fn clear(&mut self) {
        self.v.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ENot {
    // message fields
    pub p: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENot {
    fn default() -> &'a ENot {
        <ENot as ::protobuf::Message>::default_instance()
    }
}

impl ENot {
    pub fn new() -> ENot {
        ::std::default::Default::default()
    }

    // .Par p = 1;


    pub fn get_p(&self) -> &Par {
        self.p.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p(&mut self) {
        self.p.clear();
    }

    pub fn has_p(&self) -> bool {
        self.p.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p(&mut self, v: Par) {
        self.p = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p(&mut self) -> &mut Par {
        if self.p.is_none() {
            self.p.set_default();
        }
        self.p.as_mut().unwrap()
    }

    // Take field
    pub fn take_p(&mut self) -> Par {
        self.p.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for ENot {
    fn is_initialized(&self) -> bool {
        for v in &self.p {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENot {
        ENot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p",
                |m: &ENot| { &m.p },
                |m: &mut ENot| { &mut m.p },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENot>(
                "ENot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENot {
        static instance: ::protobuf::rt::LazyV2<ENot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENot::new)
    }
}

impl ::protobuf::Clear for ENot {
    fn clear(&mut self) {
        self.p.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ENeg {
    // message fields
    pub p: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENeg {
    fn default() -> &'a ENeg {
        <ENeg as ::protobuf::Message>::default_instance()
    }
}

impl ENeg {
    pub fn new() -> ENeg {
        ::std::default::Default::default()
    }

    // .Par p = 1;


    pub fn get_p(&self) -> &Par {
        self.p.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p(&mut self) {
        self.p.clear();
    }

    pub fn has_p(&self) -> bool {
        self.p.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p(&mut self, v: Par) {
        self.p = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p(&mut self) -> &mut Par {
        if self.p.is_none() {
            self.p.set_default();
        }
        self.p.as_mut().unwrap()
    }

    // Take field
    pub fn take_p(&mut self) -> Par {
        self.p.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for ENeg {
    fn is_initialized(&self) -> bool {
        for v in &self.p {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENeg {
        ENeg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p",
                |m: &ENeg| { &m.p },
                |m: &mut ENeg| { &mut m.p },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENeg>(
                "ENeg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENeg {
        static instance: ::protobuf::rt::LazyV2<ENeg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENeg::new)
    }
}

impl ::protobuf::Clear for ENeg {
    fn clear(&mut self) {
        self.p.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENeg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENeg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMult {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMult {
    fn default() -> &'a EMult {
        <EMult as ::protobuf::Message>::default_instance()
    }
}

impl EMult {
    pub fn new() -> EMult {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EMult {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMult {
        EMult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EMult| { &m.p1 },
                |m: &mut EMult| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EMult| { &m.p2 },
                |m: &mut EMult| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMult>(
                "EMult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMult {
        static instance: ::protobuf::rt::LazyV2<EMult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMult::new)
    }
}

impl ::protobuf::Clear for EMult {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EDiv {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EDiv {
    fn default() -> &'a EDiv {
        <EDiv as ::protobuf::Message>::default_instance()
    }
}

impl EDiv {
    pub fn new() -> EDiv {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EDiv {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EDiv {
        EDiv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EDiv| { &m.p1 },
                |m: &mut EDiv| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EDiv| { &m.p2 },
                |m: &mut EDiv| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EDiv>(
                "EDiv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EDiv {
        static instance: ::protobuf::rt::LazyV2<EDiv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EDiv::new)
    }
}

impl ::protobuf::Clear for EDiv {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EDiv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EDiv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMod {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMod {
    fn default() -> &'a EMod {
        <EMod as ::protobuf::Message>::default_instance()
    }
}

impl EMod {
    pub fn new() -> EMod {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EMod {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMod {
        EMod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EMod| { &m.p1 },
                |m: &mut EMod| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EMod| { &m.p2 },
                |m: &mut EMod| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMod>(
                "EMod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMod {
        static instance: ::protobuf::rt::LazyV2<EMod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMod::new)
    }
}

impl ::protobuf::Clear for EMod {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EPlus {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EPlus {
    fn default() -> &'a EPlus {
        <EPlus as ::protobuf::Message>::default_instance()
    }
}

impl EPlus {
    pub fn new() -> EPlus {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EPlus {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EPlus {
        EPlus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EPlus| { &m.p1 },
                |m: &mut EPlus| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EPlus| { &m.p2 },
                |m: &mut EPlus| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EPlus>(
                "EPlus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EPlus {
        static instance: ::protobuf::rt::LazyV2<EPlus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EPlus::new)
    }
}

impl ::protobuf::Clear for EPlus {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EPlus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EPlus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMinus {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMinus {
    fn default() -> &'a EMinus {
        <EMinus as ::protobuf::Message>::default_instance()
    }
}

impl EMinus {
    pub fn new() -> EMinus {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EMinus {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMinus {
        EMinus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EMinus| { &m.p1 },
                |m: &mut EMinus| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EMinus| { &m.p2 },
                |m: &mut EMinus| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMinus>(
                "EMinus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMinus {
        static instance: ::protobuf::rt::LazyV2<EMinus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMinus::new)
    }
}

impl ::protobuf::Clear for EMinus {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMinus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMinus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ELt {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ELt {
    fn default() -> &'a ELt {
        <ELt as ::protobuf::Message>::default_instance()
    }
}

impl ELt {
    pub fn new() -> ELt {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for ELt {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ELt {
        ELt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &ELt| { &m.p1 },
                |m: &mut ELt| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &ELt| { &m.p2 },
                |m: &mut ELt| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ELt>(
                "ELt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ELt {
        static instance: ::protobuf::rt::LazyV2<ELt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ELt::new)
    }
}

impl ::protobuf::Clear for ELt {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ELt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ELt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ELte {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ELte {
    fn default() -> &'a ELte {
        <ELte as ::protobuf::Message>::default_instance()
    }
}

impl ELte {
    pub fn new() -> ELte {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for ELte {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ELte {
        ELte::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &ELte| { &m.p1 },
                |m: &mut ELte| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &ELte| { &m.p2 },
                |m: &mut ELte| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ELte>(
                "ELte",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ELte {
        static instance: ::protobuf::rt::LazyV2<ELte> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ELte::new)
    }
}

impl ::protobuf::Clear for ELte {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ELte {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ELte {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EGt {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EGt {
    fn default() -> &'a EGt {
        <EGt as ::protobuf::Message>::default_instance()
    }
}

impl EGt {
    pub fn new() -> EGt {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EGt {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EGt {
        EGt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EGt| { &m.p1 },
                |m: &mut EGt| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EGt| { &m.p2 },
                |m: &mut EGt| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EGt>(
                "EGt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EGt {
        static instance: ::protobuf::rt::LazyV2<EGt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EGt::new)
    }
}

impl ::protobuf::Clear for EGt {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EGt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EGt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EGte {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EGte {
    fn default() -> &'a EGte {
        <EGte as ::protobuf::Message>::default_instance()
    }
}

impl EGte {
    pub fn new() -> EGte {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EGte {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EGte {
        EGte::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EGte| { &m.p1 },
                |m: &mut EGte| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EGte| { &m.p2 },
                |m: &mut EGte| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EGte>(
                "EGte",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EGte {
        static instance: ::protobuf::rt::LazyV2<EGte> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EGte::new)
    }
}

impl ::protobuf::Clear for EGte {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EGte {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EGte {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EEq {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EEq {
    fn default() -> &'a EEq {
        <EEq as ::protobuf::Message>::default_instance()
    }
}

impl EEq {
    pub fn new() -> EEq {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EEq {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EEq {
        EEq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EEq| { &m.p1 },
                |m: &mut EEq| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EEq| { &m.p2 },
                |m: &mut EEq| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EEq>(
                "EEq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EEq {
        static instance: ::protobuf::rt::LazyV2<EEq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EEq::new)
    }
}

impl ::protobuf::Clear for EEq {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EEq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EEq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ENeq {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENeq {
    fn default() -> &'a ENeq {
        <ENeq as ::protobuf::Message>::default_instance()
    }
}

impl ENeq {
    pub fn new() -> ENeq {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for ENeq {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENeq {
        ENeq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &ENeq| { &m.p1 },
                |m: &mut ENeq| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &ENeq| { &m.p2 },
                |m: &mut ENeq| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENeq>(
                "ENeq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENeq {
        static instance: ::protobuf::rt::LazyV2<ENeq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENeq::new)
    }
}

impl ::protobuf::Clear for ENeq {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENeq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENeq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EAnd {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EAnd {
    fn default() -> &'a EAnd {
        <EAnd as ::protobuf::Message>::default_instance()
    }
}

impl EAnd {
    pub fn new() -> EAnd {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EAnd {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EAnd {
        EAnd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EAnd| { &m.p1 },
                |m: &mut EAnd| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EAnd| { &m.p2 },
                |m: &mut EAnd| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EAnd>(
                "EAnd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EAnd {
        static instance: ::protobuf::rt::LazyV2<EAnd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EAnd::new)
    }
}

impl ::protobuf::Clear for EAnd {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EAnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EAnd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EOr {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EOr {
    fn default() -> &'a EOr {
        <EOr as ::protobuf::Message>::default_instance()
    }
}

impl EOr {
    pub fn new() -> EOr {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EOr {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EOr {
        EOr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EOr| { &m.p1 },
                |m: &mut EOr| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EOr| { &m.p2 },
                |m: &mut EOr| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EOr>(
                "EOr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EOr {
        static instance: ::protobuf::rt::LazyV2<EOr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EOr::new)
    }
}

impl ::protobuf::Clear for EOr {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EOr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EOr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMatches {
    // message fields
    pub target: ::protobuf::SingularPtrField<Par>,
    pub pattern: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMatches {
    fn default() -> &'a EMatches {
        <EMatches as ::protobuf::Message>::default_instance()
    }
}

impl EMatches {
    pub fn new() -> EMatches {
        ::std::default::Default::default()
    }

    // .Par target = 1;


    pub fn get_target(&self) -> &Par {
        self.target.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Par) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Par {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Par {
        self.target.take().unwrap_or_else(|| Par::new())
    }

    // .Par pattern = 2;


    pub fn get_pattern(&self) -> &Par {
        self.pattern.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pattern(&mut self) {
        self.pattern.clear();
    }

    pub fn has_pattern(&self) -> bool {
        self.pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: Par) {
        self.pattern = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pattern(&mut self) -> &mut Par {
        if self.pattern.is_none() {
            self.pattern.set_default();
        }
        self.pattern.as_mut().unwrap()
    }

    // Take field
    pub fn take_pattern(&mut self) -> Par {
        self.pattern.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EMatches {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pattern {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pattern)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pattern.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pattern.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMatches {
        EMatches::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "target",
                |m: &EMatches| { &m.target },
                |m: &mut EMatches| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "pattern",
                |m: &EMatches| { &m.pattern },
                |m: &mut EMatches| { &mut m.pattern },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMatches>(
                "EMatches",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMatches {
        static instance: ::protobuf::rt::LazyV2<EMatches> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMatches::new)
    }
}

impl ::protobuf::Clear for EMatches {
    fn clear(&mut self) {
        self.target.clear();
        self.pattern.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMatches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMatches {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EPercentPercent {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EPercentPercent {
    fn default() -> &'a EPercentPercent {
        <EPercentPercent as ::protobuf::Message>::default_instance()
    }
}

impl EPercentPercent {
    pub fn new() -> EPercentPercent {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EPercentPercent {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EPercentPercent {
        EPercentPercent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EPercentPercent| { &m.p1 },
                |m: &mut EPercentPercent| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EPercentPercent| { &m.p2 },
                |m: &mut EPercentPercent| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EPercentPercent>(
                "EPercentPercent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EPercentPercent {
        static instance: ::protobuf::rt::LazyV2<EPercentPercent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EPercentPercent::new)
    }
}

impl ::protobuf::Clear for EPercentPercent {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EPercentPercent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EPercentPercent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EPlusPlus {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EPlusPlus {
    fn default() -> &'a EPlusPlus {
        <EPlusPlus as ::protobuf::Message>::default_instance()
    }
}

impl EPlusPlus {
    pub fn new() -> EPlusPlus {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EPlusPlus {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EPlusPlus {
        EPlusPlus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EPlusPlus| { &m.p1 },
                |m: &mut EPlusPlus| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EPlusPlus| { &m.p2 },
                |m: &mut EPlusPlus| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EPlusPlus>(
                "EPlusPlus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EPlusPlus {
        static instance: ::protobuf::rt::LazyV2<EPlusPlus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EPlusPlus::new)
    }
}

impl ::protobuf::Clear for EPlusPlus {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EPlusPlus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EPlusPlus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EMinusMinus {
    // message fields
    pub p1: ::protobuf::SingularPtrField<Par>,
    pub p2: ::protobuf::SingularPtrField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EMinusMinus {
    fn default() -> &'a EMinusMinus {
        <EMinusMinus as ::protobuf::Message>::default_instance()
    }
}

impl EMinusMinus {
    pub fn new() -> EMinusMinus {
        ::std::default::Default::default()
    }

    // .Par p1 = 1;


    pub fn get_p1(&self) -> &Par {
        self.p1.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: Par) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut Par {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> Par {
        self.p1.take().unwrap_or_else(|| Par::new())
    }

    // .Par p2 = 2;


    pub fn get_p2(&self) -> &Par {
        self.p2.as_ref().unwrap_or_else(|| <Par as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: Par) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut Par {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> Par {
        self.p2.take().unwrap_or_else(|| Par::new())
    }
}

impl ::protobuf::Message for EMinusMinus {
    fn is_initialized(&self) -> bool {
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EMinusMinus {
        EMinusMinus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p1",
                |m: &EMinusMinus| { &m.p1 },
                |m: &mut EMinusMinus| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "p2",
                |m: &EMinusMinus| { &m.p2 },
                |m: &mut EMinusMinus| { &mut m.p2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EMinusMinus>(
                "EMinusMinus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EMinusMinus {
        static instance: ::protobuf::rt::LazyV2<EMinusMinus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EMinusMinus::new)
    }
}

impl ::protobuf::Clear for EMinusMinus {
    fn clear(&mut self) {
        self.p1.clear();
        self.p2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EMinusMinus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EMinusMinus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Connective {
    // message oneof groups
    pub connective_instance: ::std::option::Option<Connective_oneof_connective_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connective {
    fn default() -> &'a Connective {
        <Connective as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Connective_oneof_connective_instance {
    conn_and_body(ConnectiveBody),
    conn_or_body(ConnectiveBody),
    conn_not_body(Par),
    var_ref_body(VarRef),
    conn_bool(bool),
    conn_int(bool),
    conn_string(bool),
    conn_uri(bool),
    conn_byte_array(bool),
}

impl Connective {
    pub fn new() -> Connective {
        ::std::default::Default::default()
    }

    // .ConnectiveBody conn_and_body = 1;


    pub fn get_conn_and_body(&self) -> &ConnectiveBody {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(ref v)) => v,
            _ => <ConnectiveBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_conn_and_body(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_and_body(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_and_body(&mut self, v: ConnectiveBody) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_conn_and_body(&mut self) -> &mut ConnectiveBody {
        if let ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(_)) = self.connective_instance {
        } else {
            self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(ConnectiveBody::new()));
        }
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_conn_and_body(&mut self) -> ConnectiveBody {
        if self.has_conn_and_body() {
            match self.connective_instance.take() {
                ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ConnectiveBody::new()
        }
    }

    // .ConnectiveBody conn_or_body = 2;


    pub fn get_conn_or_body(&self) -> &ConnectiveBody {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(ref v)) => v,
            _ => <ConnectiveBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_conn_or_body(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_or_body(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_or_body(&mut self, v: ConnectiveBody) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_conn_or_body(&mut self) -> &mut ConnectiveBody {
        if let ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(_)) = self.connective_instance {
        } else {
            self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(ConnectiveBody::new()));
        }
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_conn_or_body(&mut self) -> ConnectiveBody {
        if self.has_conn_or_body() {
            match self.connective_instance.take() {
                ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(v)) => v,
                _ => panic!(),
            }
        } else {
            ConnectiveBody::new()
        }
    }

    // .Par conn_not_body = 3;


    pub fn get_conn_not_body(&self) -> &Par {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(ref v)) => v,
            _ => <Par as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_conn_not_body(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_not_body(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_not_body(&mut self, v: Par) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_conn_not_body(&mut self) -> &mut Par {
        if let ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(_)) = self.connective_instance {
        } else {
            self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(Par::new()));
        }
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_conn_not_body(&mut self) -> Par {
        if self.has_conn_not_body() {
            match self.connective_instance.take() {
                ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(v)) => v,
                _ => panic!(),
            }
        } else {
            Par::new()
        }
    }

    // .VarRef var_ref_body = 4;


    pub fn get_var_ref_body(&self) -> &VarRef {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(ref v)) => v,
            _ => <VarRef as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_var_ref_body(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_var_ref_body(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_var_ref_body(&mut self, v: VarRef) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_var_ref_body(&mut self) -> &mut VarRef {
        if let ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(_)) = self.connective_instance {
        } else {
            self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(VarRef::new()));
        }
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_var_ref_body(&mut self) -> VarRef {
        if self.has_var_ref_body() {
            match self.connective_instance.take() {
                ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(v)) => v,
                _ => panic!(),
            }
        } else {
            VarRef::new()
        }
    }

    // bool conn_bool = 5;


    pub fn get_conn_bool(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_bool(v)) => v,
            _ => false,
        }
    }
    pub fn clear_conn_bool(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_bool(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_bool(&mut self, v: bool) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_bool(v))
    }

    // bool conn_int = 6;


    pub fn get_conn_int(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_int(v)) => v,
            _ => false,
        }
    }
    pub fn clear_conn_int(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_int(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_int(&mut self, v: bool) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_int(v))
    }

    // bool conn_string = 7;


    pub fn get_conn_string(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_string(v)) => v,
            _ => false,
        }
    }
    pub fn clear_conn_string(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_string(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_string(&mut self, v: bool) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_string(v))
    }

    // bool conn_uri = 8;


    pub fn get_conn_uri(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_uri(v)) => v,
            _ => false,
        }
    }
    pub fn clear_conn_uri(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_uri(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_uri(&mut self, v: bool) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_uri(v))
    }

    // bool conn_byte_array = 9;


    pub fn get_conn_byte_array(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_byte_array(v)) => v,
            _ => false,
        }
    }
    pub fn clear_conn_byte_array(&mut self) {
        self.connective_instance = ::std::option::Option::None;
    }

    pub fn has_conn_byte_array(&self) -> bool {
        match self.connective_instance {
            ::std::option::Option::Some(Connective_oneof_connective_instance::conn_byte_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conn_byte_array(&mut self, v: bool) {
        self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_byte_array(v))
    }
}

impl ::protobuf::Message for Connective {
    fn is_initialized(&self) -> bool {
        if let Some(Connective_oneof_connective_instance::conn_and_body(ref v)) = self.connective_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connective_oneof_connective_instance::conn_or_body(ref v)) = self.connective_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connective_oneof_connective_instance::conn_not_body(ref v)) = self.connective_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Connective_oneof_connective_instance::var_ref_body(ref v)) = self.connective_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_and_body(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_or_body(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_not_body(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::var_ref_body(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_bool(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_int(is.read_bool()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_string(is.read_bool()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_uri(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connective_instance = ::std::option::Option::Some(Connective_oneof_connective_instance::conn_byte_array(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.connective_instance {
            match v {
                &Connective_oneof_connective_instance::conn_and_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connective_oneof_connective_instance::conn_or_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connective_oneof_connective_instance::conn_not_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connective_oneof_connective_instance::var_ref_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Connective_oneof_connective_instance::conn_bool(v) => {
                    my_size += 2;
                },
                &Connective_oneof_connective_instance::conn_int(v) => {
                    my_size += 2;
                },
                &Connective_oneof_connective_instance::conn_string(v) => {
                    my_size += 2;
                },
                &Connective_oneof_connective_instance::conn_uri(v) => {
                    my_size += 2;
                },
                &Connective_oneof_connective_instance::conn_byte_array(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.connective_instance {
            match v {
                &Connective_oneof_connective_instance::conn_and_body(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connective_oneof_connective_instance::conn_or_body(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connective_oneof_connective_instance::conn_not_body(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connective_oneof_connective_instance::var_ref_body(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Connective_oneof_connective_instance::conn_bool(v) => {
                    os.write_bool(5, v)?;
                },
                &Connective_oneof_connective_instance::conn_int(v) => {
                    os.write_bool(6, v)?;
                },
                &Connective_oneof_connective_instance::conn_string(v) => {
                    os.write_bool(7, v)?;
                },
                &Connective_oneof_connective_instance::conn_uri(v) => {
                    os.write_bool(8, v)?;
                },
                &Connective_oneof_connective_instance::conn_byte_array(v) => {
                    os.write_bool(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connective {
        Connective::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConnectiveBody>(
                "conn_and_body",
                Connective::has_conn_and_body,
                Connective::get_conn_and_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConnectiveBody>(
                "conn_or_body",
                Connective::has_conn_or_body,
                Connective::get_conn_or_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Par>(
                "conn_not_body",
                Connective::has_conn_not_body,
                Connective::get_conn_not_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VarRef>(
                "var_ref_body",
                Connective::has_var_ref_body,
                Connective::get_var_ref_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "conn_bool",
                Connective::has_conn_bool,
                Connective::get_conn_bool,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "conn_int",
                Connective::has_conn_int,
                Connective::get_conn_int,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "conn_string",
                Connective::has_conn_string,
                Connective::get_conn_string,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "conn_uri",
                Connective::has_conn_uri,
                Connective::get_conn_uri,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "conn_byte_array",
                Connective::has_conn_byte_array,
                Connective::get_conn_byte_array,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connective>(
                "Connective",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connective {
        static instance: ::protobuf::rt::LazyV2<Connective> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connective::new)
    }
}

impl ::protobuf::Clear for Connective {
    fn clear(&mut self) {
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.connective_instance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connective {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VarRef {
    // message fields
    pub index: i32,
    pub depth: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VarRef {
    fn default() -> &'a VarRef {
        <VarRef as ::protobuf::Message>::default_instance()
    }
}

impl VarRef {
    pub fn new() -> VarRef {
        ::std::default::Default::default()
    }

    // sint32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // sint32 depth = 2;


    pub fn get_depth(&self) -> i32 {
        self.depth
    }
    pub fn clear_depth(&mut self) {
        self.depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: i32) {
        self.depth = v;
    }
}

impl ::protobuf::Message for VarRef {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.depth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.index);
        }
        if self.depth != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.depth);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_sint32(1, self.index)?;
        }
        if self.depth != 0 {
            os.write_sint32(2, self.depth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VarRef {
        VarRef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "index",
                |m: &VarRef| { &m.index },
                |m: &mut VarRef| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "depth",
                |m: &VarRef| { &m.depth },
                |m: &mut VarRef| { &mut m.depth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VarRef>(
                "VarRef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VarRef {
        static instance: ::protobuf::rt::LazyV2<VarRef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VarRef::new)
    }
}

impl ::protobuf::Clear for VarRef {
    fn clear(&mut self) {
        self.index = 0;
        self.depth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VarRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VarRef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectiveBody {
    // message fields
    pub ps: ::protobuf::RepeatedField<Par>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectiveBody {
    fn default() -> &'a ConnectiveBody {
        <ConnectiveBody as ::protobuf::Message>::default_instance()
    }
}

impl ConnectiveBody {
    pub fn new() -> ConnectiveBody {
        ::std::default::Default::default()
    }

    // repeated .Par ps = 1;


    pub fn get_ps(&self) -> &[Par] {
        &self.ps
    }
    pub fn clear_ps(&mut self) {
        self.ps.clear();
    }

    // Param is passed by value, moved
    pub fn set_ps(&mut self, v: ::protobuf::RepeatedField<Par>) {
        self.ps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ps(&mut self) -> &mut ::protobuf::RepeatedField<Par> {
        &mut self.ps
    }

    // Take field
    pub fn take_ps(&mut self) -> ::protobuf::RepeatedField<Par> {
        ::std::mem::replace(&mut self.ps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnectiveBody {
    fn is_initialized(&self) -> bool {
        for v in &self.ps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectiveBody {
        ConnectiveBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Par>>(
                "ps",
                |m: &ConnectiveBody| { &m.ps },
                |m: &mut ConnectiveBody| { &mut m.ps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectiveBody>(
                "ConnectiveBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectiveBody {
        static instance: ::protobuf::rt::LazyV2<ConnectiveBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectiveBody::new)
    }
}

impl ::protobuf::Clear for ConnectiveBody {
    fn clear(&mut self) {
        self.ps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectiveBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectiveBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeployId {
    // message fields
    pub sig: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployId {
    fn default() -> &'a DeployId {
        <DeployId as ::protobuf::Message>::default_instance()
    }
}

impl DeployId {
    pub fn new() -> DeployId {
        ::std::default::Default::default()
    }

    // bytes sig = 1;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::bytes::Bytes) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::bytes::Bytes {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.sig, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for DeployId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sig.is_empty() {
            os.write_bytes(1, &self.sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployId {
        DeployId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "sig",
                |m: &DeployId| { &m.sig },
                |m: &mut DeployId| { &mut m.sig },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployId>(
                "DeployId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeployId {
        static instance: ::protobuf::rt::LazyV2<DeployId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeployId::new)
    }
}

impl ::protobuf::Clear for DeployId {
    fn clear(&mut self) {
        self.sig.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeployerId {
    // message fields
    pub publicKey: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployerId {
    fn default() -> &'a DeployerId {
        <DeployerId as ::protobuf::Message>::default_instance()
    }
}

impl DeployerId {
    pub fn new() -> DeployerId {
        ::std::default::Default::default()
    }

    // bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        &self.publicKey
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::bytes::Bytes) {
        self.publicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::bytes::Bytes {
        &mut self.publicKey
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.publicKey, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for DeployerId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.publicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.publicKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.publicKey.is_empty() {
            os.write_bytes(1, &self.publicKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployerId {
        DeployerId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "publicKey",
                |m: &DeployerId| { &m.publicKey },
                |m: &mut DeployerId| { &mut m.publicKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployerId>(
                "DeployerId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeployerId {
        static instance: ::protobuf::rt::LazyV2<DeployerId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeployerId::new)
    }
}

impl ::protobuf::Clear for DeployerId {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployerId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployerId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GUnforgeable {
    // message oneof groups
    pub unf_instance: ::std::option::Option<GUnforgeable_oneof_unf_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GUnforgeable {
    fn default() -> &'a GUnforgeable {
        <GUnforgeable as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GUnforgeable_oneof_unf_instance {
    g_private_body(GPrivate),
    g_deploy_id_body(GDeployId),
    g_deployer_id_body(GDeployerId),
    g_sys_auth_token_body(GSysAuthToken),
}

impl GUnforgeable {
    pub fn new() -> GUnforgeable {
        ::std::default::Default::default()
    }

    // .GPrivate g_private_body = 1;


    pub fn get_g_private_body(&self) -> &GPrivate {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(ref v)) => v,
            _ => <GPrivate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_g_private_body(&mut self) {
        self.unf_instance = ::std::option::Option::None;
    }

    pub fn has_g_private_body(&self) -> bool {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_private_body(&mut self, v: GPrivate) {
        self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_private_body(&mut self) -> &mut GPrivate {
        if let ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(_)) = self.unf_instance {
        } else {
            self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(GPrivate::new()));
        }
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_private_body(&mut self) -> GPrivate {
        if self.has_g_private_body() {
            match self.unf_instance.take() {
                ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(v)) => v,
                _ => panic!(),
            }
        } else {
            GPrivate::new()
        }
    }

    // .GDeployId g_deploy_id_body = 2;


    pub fn get_g_deploy_id_body(&self) -> &GDeployId {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(ref v)) => v,
            _ => <GDeployId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_g_deploy_id_body(&mut self) {
        self.unf_instance = ::std::option::Option::None;
    }

    pub fn has_g_deploy_id_body(&self) -> bool {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_deploy_id_body(&mut self, v: GDeployId) {
        self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_deploy_id_body(&mut self) -> &mut GDeployId {
        if let ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(_)) = self.unf_instance {
        } else {
            self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(GDeployId::new()));
        }
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_deploy_id_body(&mut self) -> GDeployId {
        if self.has_g_deploy_id_body() {
            match self.unf_instance.take() {
                ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(v)) => v,
                _ => panic!(),
            }
        } else {
            GDeployId::new()
        }
    }

    // .GDeployerId g_deployer_id_body = 3;


    pub fn get_g_deployer_id_body(&self) -> &GDeployerId {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(ref v)) => v,
            _ => <GDeployerId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_g_deployer_id_body(&mut self) {
        self.unf_instance = ::std::option::Option::None;
    }

    pub fn has_g_deployer_id_body(&self) -> bool {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_deployer_id_body(&mut self, v: GDeployerId) {
        self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_deployer_id_body(&mut self) -> &mut GDeployerId {
        if let ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(_)) = self.unf_instance {
        } else {
            self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(GDeployerId::new()));
        }
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_deployer_id_body(&mut self) -> GDeployerId {
        if self.has_g_deployer_id_body() {
            match self.unf_instance.take() {
                ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(v)) => v,
                _ => panic!(),
            }
        } else {
            GDeployerId::new()
        }
    }

    // .GSysAuthToken g_sys_auth_token_body = 4;


    pub fn get_g_sys_auth_token_body(&self) -> &GSysAuthToken {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(ref v)) => v,
            _ => <GSysAuthToken as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_g_sys_auth_token_body(&mut self) {
        self.unf_instance = ::std::option::Option::None;
    }

    pub fn has_g_sys_auth_token_body(&self) -> bool {
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g_sys_auth_token_body(&mut self, v: GSysAuthToken) {
        self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g_sys_auth_token_body(&mut self) -> &mut GSysAuthToken {
        if let ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(_)) = self.unf_instance {
        } else {
            self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(GSysAuthToken::new()));
        }
        match self.unf_instance {
            ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g_sys_auth_token_body(&mut self) -> GSysAuthToken {
        if self.has_g_sys_auth_token_body() {
            match self.unf_instance.take() {
                ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(v)) => v,
                _ => panic!(),
            }
        } else {
            GSysAuthToken::new()
        }
    }
}

impl ::protobuf::Message for GUnforgeable {
    fn is_initialized(&self) -> bool {
        if let Some(GUnforgeable_oneof_unf_instance::g_private_body(ref v)) = self.unf_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(ref v)) = self.unf_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(ref v)) = self.unf_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(ref v)) = self.unf_instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_private_body(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deploy_id_body(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_deployer_id_body(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.unf_instance = ::std::option::Option::Some(GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.unf_instance {
            match v {
                &GUnforgeable_oneof_unf_instance::g_private_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GUnforgeable_oneof_unf_instance::g_deploy_id_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GUnforgeable_oneof_unf_instance::g_deployer_id_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.unf_instance {
            match v {
                &GUnforgeable_oneof_unf_instance::g_private_body(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GUnforgeable_oneof_unf_instance::g_deploy_id_body(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GUnforgeable_oneof_unf_instance::g_deployer_id_body(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GUnforgeable_oneof_unf_instance::g_sys_auth_token_body(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GUnforgeable {
        GUnforgeable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GPrivate>(
                "g_private_body",
                GUnforgeable::has_g_private_body,
                GUnforgeable::get_g_private_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GDeployId>(
                "g_deploy_id_body",
                GUnforgeable::has_g_deploy_id_body,
                GUnforgeable::get_g_deploy_id_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GDeployerId>(
                "g_deployer_id_body",
                GUnforgeable::has_g_deployer_id_body,
                GUnforgeable::get_g_deployer_id_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GSysAuthToken>(
                "g_sys_auth_token_body",
                GUnforgeable::has_g_sys_auth_token_body,
                GUnforgeable::get_g_sys_auth_token_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GUnforgeable>(
                "GUnforgeable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GUnforgeable {
        static instance: ::protobuf::rt::LazyV2<GUnforgeable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GUnforgeable::new)
    }
}

impl ::protobuf::Clear for GUnforgeable {
    fn clear(&mut self) {
        self.unf_instance = ::std::option::Option::None;
        self.unf_instance = ::std::option::Option::None;
        self.unf_instance = ::std::option::Option::None;
        self.unf_instance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GUnforgeable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GUnforgeable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GPrivate {
    // message fields
    pub id: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GPrivate {
    fn default() -> &'a GPrivate {
        <GPrivate as ::protobuf::Message>::default_instance()
    }
}

impl GPrivate {
    pub fn new() -> GPrivate {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::bytes::Bytes) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.id, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for GPrivate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GPrivate {
        GPrivate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "id",
                |m: &GPrivate| { &m.id },
                |m: &mut GPrivate| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GPrivate>(
                "GPrivate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GPrivate {
        static instance: ::protobuf::rt::LazyV2<GPrivate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GPrivate::new)
    }
}

impl ::protobuf::Clear for GPrivate {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GPrivate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GDeployId {
    // message fields
    pub sig: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GDeployId {
    fn default() -> &'a GDeployId {
        <GDeployId as ::protobuf::Message>::default_instance()
    }
}

impl GDeployId {
    pub fn new() -> GDeployId {
        ::std::default::Default::default()
    }

    // bytes sig = 1;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::bytes::Bytes) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::bytes::Bytes {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.sig, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for GDeployId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sig.is_empty() {
            os.write_bytes(1, &self.sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GDeployId {
        GDeployId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "sig",
                |m: &GDeployId| { &m.sig },
                |m: &mut GDeployId| { &mut m.sig },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GDeployId>(
                "GDeployId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GDeployId {
        static instance: ::protobuf::rt::LazyV2<GDeployId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GDeployId::new)
    }
}

impl ::protobuf::Clear for GDeployId {
    fn clear(&mut self) {
        self.sig.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GDeployId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GDeployId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GDeployerId {
    // message fields
    pub publicKey: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GDeployerId {
    fn default() -> &'a GDeployerId {
        <GDeployerId as ::protobuf::Message>::default_instance()
    }
}

impl GDeployerId {
    pub fn new() -> GDeployerId {
        ::std::default::Default::default()
    }

    // bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        &self.publicKey
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::bytes::Bytes) {
        self.publicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::bytes::Bytes {
        &mut self.publicKey
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.publicKey, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for GDeployerId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.publicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.publicKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.publicKey.is_empty() {
            os.write_bytes(1, &self.publicKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GDeployerId {
        GDeployerId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "publicKey",
                |m: &GDeployerId| { &m.publicKey },
                |m: &mut GDeployerId| { &mut m.publicKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GDeployerId>(
                "GDeployerId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GDeployerId {
        static instance: ::protobuf::rt::LazyV2<GDeployerId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GDeployerId::new)
    }
}

impl ::protobuf::Clear for GDeployerId {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GDeployerId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GDeployerId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GSysAuthToken {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GSysAuthToken {
    fn default() -> &'a GSysAuthToken {
        <GSysAuthToken as ::protobuf::Message>::default_instance()
    }
}

impl GSysAuthToken {
    pub fn new() -> GSysAuthToken {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GSysAuthToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GSysAuthToken {
        GSysAuthToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GSysAuthToken>(
                "GSysAuthToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GSysAuthToken {
        static instance: ::protobuf::rt::LazyV2<GSysAuthToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GSysAuthToken::new)
    }
}

impl ::protobuf::Clear for GSysAuthToken {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GSysAuthToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GSysAuthToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0frho_types.proto\x1a\x0frustproto.proto\"\xf1\x02\n\x03Par\x12\x1b\
    \n\x05sends\x18\x01\x20\x03(\x0b2\x05.SendR\x05sends\x12$\n\x08receives\
    \x18\x02\x20\x03(\x0b2\x08.ReceiveR\x08receives\x12\x18\n\x04news\x18\
    \x04\x20\x03(\x0b2\x04.NewR\x04news\x12\x1b\n\x05exprs\x18\x05\x20\x03(\
    \x0b2\x05.ExprR\x05exprs\x12\x20\n\x07matches\x18\x06\x20\x03(\x0b2\x06.\
    MatchR\x07matches\x121\n\x0cunforgeables\x18\x07\x20\x03(\x0b2\r.GUnforg\
    eableR\x0cunforgeables\x12!\n\x07bundles\x18\x0b\x20\x03(\x0b2\x07.Bundl\
    eR\x07bundles\x12-\n\x0bconnectives\x18\x08\x20\x03(\x0b2\x0b.Connective\
    R\x0bconnectives\x12\x20\n\x0blocallyFree\x18\t\x20\x01(\x0cR\x0blocally\
    Free\x12'\n\x0fconnective_used\x18\n\x20\x01(\x08R\x0econnectiveUsed\"x\
    \n\x12TaggedContinuation\x12+\n\x08par_body\x18\x01\x20\x01(\x0b2\x0e.Pa\
    rWithRandomH\0R\x07parBody\x12&\n\x0escala_body_ref\x18\x02\x20\x01(\x03\
    H\0R\x0cscalaBodyRefB\r\n\x0btagged_cont\"K\n\rParWithRandom\x12\x18\n\
    \x04body\x18\x01\x20\x01(\x0b2\x04.ParR\x04body\x12\x20\n\x0brandomState\
    \x18\x02\x20\x01(\x0cR\x0brandomState\"\x1b\n\x05PCost\x12\x12\n\x04cost\
    \x18\x01\x20\x01(\x04R\x04cost\"O\n\x11ListParWithRandom\x12\x18\n\x04pa\
    rs\x18\x01\x20\x03(\x0b2\x04.ParR\x04pars\x12\x20\n\x0brandomState\x18\
    \x02\x20\x01(\x0cR\x0brandomState\"\x90\x01\n\x03Var\x12\x1d\n\tbound_va\
    r\x18\x01\x20\x01(\x11H\0R\x08boundVar\x12\x1b\n\x08free_var\x18\x02\x20\
    \x01(\x11H\0R\x07freeVar\x12.\n\x08wildcard\x18\x03\x20\x01(\x0b2\x10.Va\
    r.WildcardMsgH\0R\x08wildcard\x1a\r\n\x0bWildcardMsgB\x0e\n\x0cvar_insta\
    nce\"\\\n\x06Bundle\x12\x18\n\x04body\x18\x01\x20\x01(\x0b2\x04.ParR\x04\
    body\x12\x1c\n\twriteFlag\x18\x02\x20\x01(\x08R\twriteFlag\x12\x1a\n\x08\
    readFlag\x18\x03\x20\x01(\x08R\x08readFlag\"\xa5\x01\n\x04Send\x12\x18\n\
    \x04chan\x18\x01\x20\x01(\x0b2\x04.ParR\x04chan\x12\x18\n\x04data\x18\
    \x02\x20\x03(\x0b2\x04.ParR\x04data\x12\x1e\n\npersistent\x18\x03\x20\
    \x01(\x08R\npersistent\x12\x20\n\x0blocallyFree\x18\x05\x20\x01(\x0cR\
    \x0blocallyFree\x12'\n\x0fconnective_used\x18\x06\x20\x01(\x08R\x0econne\
    ctiveUsed\"\x8f\x01\n\x0bReceiveBind\x12\x20\n\x08patterns\x18\x01\x20\
    \x03(\x0b2\x04.ParR\x08patterns\x12\x1c\n\x06source\x18\x02\x20\x01(\x0b\
    2\x04.ParR\x06source\x12\"\n\tremainder\x18\x03\x20\x01(\x0b2\x04.VarR\t\
    remainder\x12\x1c\n\tfreeCount\x18\x04\x20\x01(\x05R\tfreeCount\"q\n\x0b\
    BindPattern\x12\x20\n\x08patterns\x18\x01\x20\x03(\x0b2\x04.ParR\x08patt\
    erns\x12\"\n\tremainder\x18\x02\x20\x01(\x0b2\x04.VarR\tremainder\x12\
    \x1c\n\tfreeCount\x18\x03\x20\x01(\x05R\tfreeCount\"<\n\x10ListBindPatte\
    rns\x12(\n\x08patterns\x18\x01\x20\x03(\x0b2\x0c.BindPatternR\x08pattern\
    s\"\xe4\x01\n\x07Receive\x12\"\n\x05binds\x18\x01\x20\x03(\x0b2\x0c.Rece\
    iveBindR\x05binds\x12\x18\n\x04body\x18\x02\x20\x01(\x0b2\x04.ParR\x04bo\
    dy\x12\x1e\n\npersistent\x18\x03\x20\x01(\x08R\npersistent\x12\x12\n\x04\
    peek\x18\x04\x20\x01(\x08R\x04peek\x12\x1c\n\tbindCount\x18\x05\x20\x01(\
    \x05R\tbindCount\x12\x20\n\x0blocallyFree\x18\x06\x20\x01(\x0cR\x0blocal\
    lyFree\x12'\n\x0fconnective_used\x18\x07\x20\x01(\x08R\x0econnectiveUsed\
    \"\xe6\x01\n\x03New\x12\x1c\n\tbindCount\x18\x01\x20\x01(\x11R\tbindCoun\
    t\x12\x12\n\x01p\x18\x02\x20\x01(\x0b2\x04.ParR\x01p\x12\x10\n\x03uri\
    \x18\x03\x20\x03(\tR\x03uri\x124\n\ninjections\x18\x04\x20\x03(\x0b2\x14\
    .New.InjectionsEntryR\ninjections\x12\x20\n\x0blocallyFree\x18\x05\x20\
    \x01(\x0cR\x0blocallyFree\x1aC\n\x0fInjectionsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x1a\n\x05value\x18\x02\x20\x01(\x0b2\x04.Par\
    R\x05value:\x028\x01\"g\n\tMatchCase\x12\x1e\n\x07pattern\x18\x01\x20\
    \x01(\x0b2\x04.ParR\x07pattern\x12\x1c\n\x06source\x18\x02\x20\x01(\x0b2\
    \x04.ParR\x06source\x12\x1c\n\tfreeCount\x18\x03\x20\x01(\x05R\tfreeCoun\
    t\"\x92\x01\n\x05Match\x12\x1c\n\x06target\x18\x01\x20\x01(\x0b2\x04.Par\
    R\x06target\x12\x20\n\x05cases\x18\x02\x20\x03(\x0b2\n.MatchCaseR\x05cas\
    es\x12\x20\n\x0blocallyFree\x18\x04\x20\x01(\x0cR\x0blocallyFree\x12'\n\
    \x0fconnective_used\x18\x05\x20\x01(\x08R\x0econnectiveUsed\"\xd4\t\n\
    \x04Expr\x12\x17\n\x06g_bool\x18\x01\x20\x01(\x08H\0R\x05gBool\x12\x15\n\
    \x05g_int\x18\x02\x20\x01(\x12H\0R\x04gInt\x12\x1b\n\x08g_string\x18\x03\
    \x20\x01(\tH\0R\x07gString\x12\x15\n\x05g_uri\x18\x04\x20\x01(\tH\0R\x04\
    gUri\x12\"\n\x0cg_byte_array\x18\x19\x20\x01(\x0cH\0R\ngByteArray\x12%\n\
    \ne_not_body\x18\x05\x20\x01(\x0b2\x05.ENotH\0R\x08eNotBody\x12%\n\ne_ne\
    g_body\x18\x06\x20\x01(\x0b2\x05.ENegH\0R\x08eNegBody\x12(\n\x0be_mult_b\
    ody\x18\x07\x20\x01(\x0b2\x06.EMultH\0R\teMultBody\x12%\n\ne_div_body\
    \x18\x08\x20\x01(\x0b2\x05.EDivH\0R\x08eDivBody\x12(\n\x0be_plus_body\
    \x18\t\x20\x01(\x0b2\x06.EPlusH\0R\tePlusBody\x12+\n\x0ce_minus_body\x18\
    \n\x20\x01(\x0b2\x07.EMinusH\0R\neMinusBody\x12\"\n\te_lt_body\x18\x0b\
    \x20\x01(\x0b2\x04.ELtH\0R\x07eLtBody\x12%\n\ne_lte_body\x18\x0c\x20\x01\
    (\x0b2\x05.ELteH\0R\x08eLteBody\x12\"\n\te_gt_body\x18\r\x20\x01(\x0b2\
    \x04.EGtH\0R\x07eGtBody\x12%\n\ne_gte_body\x18\x0e\x20\x01(\x0b2\x05.EGt\
    eH\0R\x08eGteBody\x12\"\n\te_eq_body\x18\x0f\x20\x01(\x0b2\x04.EEqH\0R\
    \x07eEqBody\x12%\n\ne_neq_body\x18\x10\x20\x01(\x0b2\x05.ENeqH\0R\x08eNe\
    qBody\x12%\n\ne_and_body\x18\x11\x20\x01(\x0b2\x05.EAndH\0R\x08eAndBody\
    \x12\"\n\te_or_body\x18\x12\x20\x01(\x0b2\x04.EOrH\0R\x07eOrBody\x12%\n\
    \ne_var_body\x18\x13\x20\x01(\x0b2\x05.EVarH\0R\x08eVarBody\x12(\n\x0be_\
    list_body\x18\x14\x20\x01(\x0b2\x06.EListH\0R\teListBody\x12+\n\x0ce_tup\
    le_body\x18\x15\x20\x01(\x0b2\x07.ETupleH\0R\neTupleBody\x12%\n\ne_set_b\
    ody\x18\x16\x20\x01(\x0b2\x05.ESetH\0R\x08eSetBody\x12%\n\ne_map_body\
    \x18\x17\x20\x01(\x0b2\x05.EMapH\0R\x08eMapBody\x12.\n\re_method_body\
    \x18\x18\x20\x01(\x0b2\x08.EMethodH\0R\x0beMethodBody\x121\n\x0ee_matche\
    s_body\x18\x1b\x20\x01(\x0b2\t.EMatchesH\0R\x0ceMatchesBody\x12G\n\x16e_\
    percent_percent_body\x18\x1c\x20\x01(\x0b2\x10.EPercentPercentH\0R\x13eP\
    ercentPercentBody\x125\n\x10e_plus_plus_body\x18\x1d\x20\x01(\x0b2\n.EPl\
    usPlusH\0R\rePlusPlusBody\x12;\n\x12e_minus_minus_body\x18\x1e\x20\x01(\
    \x0b2\x0c.EMinusMinusH\0R\x0feMinusMinusBody\x12%\n\ne_mod_body\x18\x1f\
    \x20\x01(\x0b2\x05.EModH\0R\x08eModBodyB\x0f\n\rexpr_instance\"\x8c\x01\
    \n\x05EList\x12\x14\n\x02ps\x18\x01\x20\x03(\x0b2\x04.ParR\x02ps\x12\x20\
    \n\x0blocallyFree\x18\x03\x20\x01(\x0cR\x0blocallyFree\x12'\n\x0fconnect\
    ive_used\x18\x04\x20\x01(\x08R\x0econnectiveUsed\x12\"\n\tremainder\x18\
    \x05\x20\x01(\x0b2\x04.VarR\tremainder\"i\n\x06ETuple\x12\x14\n\x02ps\
    \x18\x01\x20\x03(\x0b2\x04.ParR\x02ps\x12\x20\n\x0blocallyFree\x18\x03\
    \x20\x01(\x0cR\x0blocallyFree\x12'\n\x0fconnective_used\x18\x04\x20\x01(\
    \x08R\x0econnectiveUsed\"\x8b\x01\n\x04ESet\x12\x14\n\x02ps\x18\x01\x20\
    \x03(\x0b2\x04.ParR\x02ps\x12\x20\n\x0blocallyFree\x18\x03\x20\x01(\x0cR\
    \x0blocallyFree\x12'\n\x0fconnective_used\x18\x04\x20\x01(\x08R\x0econne\
    ctiveUsed\x12\"\n\tremainder\x18\x05\x20\x01(\x0b2\x04.VarR\tremainder\"\
    \x96\x01\n\x04EMap\x12\x1f\n\x03kvs\x18\x01\x20\x03(\x0b2\r.KeyValuePair\
    R\x03kvs\x12\x20\n\x0blocallyFree\x18\x03\x20\x01(\x0cR\x0blocallyFree\
    \x12'\n\x0fconnective_used\x18\x04\x20\x01(\x08R\x0econnectiveUsed\x12\"\
    \n\tremainder\x18\x05\x20\x01(\x0b2\x04.VarR\tremainder\"\xb6\x01\n\x07E\
    Method\x12\x1e\n\nmethodName\x18\x01\x20\x01(\tR\nmethodName\x12\x1c\n\
    \x06target\x18\x02\x20\x01(\x0b2\x04.ParR\x06target\x12\"\n\targuments\
    \x18\x03\x20\x03(\x0b2\x04.ParR\targuments\x12\x20\n\x0blocallyFree\x18\
    \x05\x20\x01(\x0cR\x0blocallyFree\x12'\n\x0fconnective_used\x18\x06\x20\
    \x01(\x08R\x0econnectiveUsed\"B\n\x0cKeyValuePair\x12\x16\n\x03key\x18\
    \x01\x20\x01(\x0b2\x04.ParR\x03key\x12\x1a\n\x05value\x18\x02\x20\x01(\
    \x0b2\x04.ParR\x05value\"\x1a\n\x04EVar\x12\x12\n\x01v\x18\x01\x20\x01(\
    \x0b2\x04.VarR\x01v\"\x1a\n\x04ENot\x12\x12\n\x01p\x18\x01\x20\x01(\x0b2\
    \x04.ParR\x01p\"\x1a\n\x04ENeg\x12\x12\n\x01p\x18\x01\x20\x01(\x0b2\x04.\
    ParR\x01p\"3\n\x05EMult\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\
    \x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"2\n\x04EDiv\
    \x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\
    \x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"2\n\x04EMod\x12\x14\n\x02p1\x18\
    \x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\
    \x04.ParR\x02p2\"3\n\x05EPlus\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.\
    ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"4\n\x06\
    EMinus\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\
    \x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"1\n\x03ELt\x12\x14\n\x02p1\
    \x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\
    \x0b2\x04.ParR\x02p2\"2\n\x04ELte\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\
    \x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"1\
    \n\x03EGt\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\
    \x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"2\n\x04EGte\x12\x14\n\x02p1\
    \x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\
    \x0b2\x04.ParR\x02p2\"1\n\x03EEq\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\
    \x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"2\
    \n\x04ENeq\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\
    \n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"2\n\x04EAnd\x12\x14\n\x02\
    p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\
    \x0b2\x04.ParR\x02p2\"1\n\x03EOr\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\
    \x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"H\
    \n\x08EMatches\x12\x1c\n\x06target\x18\x01\x20\x01(\x0b2\x04.ParR\x06tar\
    get\x12\x1e\n\x07pattern\x18\x02\x20\x01(\x0b2\x04.ParR\x07pattern\"=\n\
    \x0fEPercentPercent\x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\
    \x12\x14\n\x02p2\x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"7\n\tEPlusPlus\
    \x12\x14\n\x02p1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\
    \x18\x02\x20\x01(\x0b2\x04.ParR\x02p2\"9\n\x0bEMinusMinus\x12\x14\n\x02p\
    1\x18\x01\x20\x01(\x0b2\x04.ParR\x02p1\x12\x14\n\x02p2\x18\x02\x20\x01(\
    \x0b2\x04.ParR\x02p2\"\x8e\x03\n\nConnective\x125\n\rconn_and_body\x18\
    \x01\x20\x01(\x0b2\x0f.ConnectiveBodyH\0R\x0bconnAndBody\x123\n\x0cconn_\
    or_body\x18\x02\x20\x01(\x0b2\x0f.ConnectiveBodyH\0R\nconnOrBody\x12*\n\
    \rconn_not_body\x18\x03\x20\x01(\x0b2\x04.ParH\0R\x0bconnNotBody\x12+\n\
    \x0cvar_ref_body\x18\x04\x20\x01(\x0b2\x07.VarRefH\0R\nvarRefBody\x12\
    \x1d\n\tconn_bool\x18\x05\x20\x01(\x08H\0R\x08connBool\x12\x1b\n\x08conn\
    _int\x18\x06\x20\x01(\x08H\0R\x07connInt\x12!\n\x0bconn_string\x18\x07\
    \x20\x01(\x08H\0R\nconnString\x12\x1b\n\x08conn_uri\x18\x08\x20\x01(\x08\
    H\0R\x07connUri\x12(\n\x0fconn_byte_array\x18\t\x20\x01(\x08H\0R\rconnBy\
    teArrayB\x15\n\x13connective_instance\"4\n\x06VarRef\x12\x14\n\x05index\
    \x18\x01\x20\x01(\x11R\x05index\x12\x14\n\x05depth\x18\x02\x20\x01(\x11R\
    \x05depth\"&\n\x0eConnectiveBody\x12\x14\n\x02ps\x18\x01\x20\x03(\x0b2\
    \x04.ParR\x02ps\"\x1c\n\x08DeployId\x12\x10\n\x03sig\x18\x01\x20\x01(\
    \x0cR\x03sig\"*\n\nDeployerId\x12\x1c\n\tpublicKey\x18\x01\x20\x01(\x0cR\
    \tpublicKey\"\x89\x02\n\x0cGUnforgeable\x121\n\x0eg_private_body\x18\x01\
    \x20\x01(\x0b2\t.GPrivateH\0R\x0cgPrivateBody\x125\n\x10g_deploy_id_body\
    \x18\x02\x20\x01(\x0b2\n.GDeployIdH\0R\rgDeployIdBody\x12;\n\x12g_deploy\
    er_id_body\x18\x03\x20\x01(\x0b2\x0c.GDeployerIdH\0R\x0fgDeployerIdBody\
    \x12B\n\x15g_sys_auth_token_body\x18\x04\x20\x01(\x0b2\x0e.GSysAuthToken\
    H\0R\x11gSysAuthTokenBodyB\x0e\n\x0cunf_instance\"\x1a\n\x08GPrivate\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\"\x1d\n\tGDeployId\x12\x10\n\
    \x03sig\x18\x01\x20\x01(\x0cR\x03sig\"+\n\x0bGDeployerId\x12\x1c\n\tpubl\
    icKey\x18\x01\x20\x01(\x0cR\tpublicKey\"\x0f\n\rGSysAuthTokenB\x04\x98\
    \xa7\x08\x01J\xd6|\n\x07\x12\x05\x05\0\xab\x03\x18\n>\n\x01\x0c\x12\x03\
    \x05\0\x12\x1a4*\n\x20Rholang\x20Term\x20Structure\n\n\x20The\x20top\x20\
    level\x20is\x20`Par`.\n\nZ\n\x02\x03\0\x12\x03\x08\0\x19\x1aO\x20https:/\
    /github.com/stepancheg/rust-protobuf/blob/master/proto/rustproto.proto\n\
    \n\x08\n\x01\x08\x12\x03\n\09\n@\n\x04\x08\xf3\x84\x01\x12\x03\n\09\"3op\
    tion\x20(rustproto.generate_accessors_all)\x20=\x20false;\n\n\xfc\x05\n\
    \x02\x04\0\x12\x04%\00\x01\x1a\xa6\x01*\n\x20Rholang\x20process\n\n\x20F\
    or\x20example,\x20`@0!(1)\x20|\x20@2!(3)\x20|\x20for(x\x20<-\x20@0)\x20{\
    \x20Nil\x20}`\x20has\x20two\x20sends\n\x20and\x20one\x20receive.\n\n\x20\
    The\x20Nil\x20process\x20is\x20a\x20`Par`\x20with\x20no\x20sends,\x20rec\
    eives,\x20etc.\n2\xf8\x01\x20If\x20you\x20are\x20building\x20for\x20othe\
    r\x20languages\x20\"scalapb.proto\"\n\x20can\x20be\x20manually\x20obtain\
    ed\x20here:\n\x20https://raw.githubusercontent.com/scalapb/ScalaPB/maste\
    r/protobuf/scalapb/scalapb.proto\n\x20make\x20a\x20scalapb\x20directory\
    \x20in\x20this\x20file's\x20location\x20and\x20place\x20it\x20inside\n2\
    \xcb\x02\nimport\x20\"scalapb/scalapb.proto\";\n\noption\x20(scalapb.opt\
    ions)\x20=\x20{\npackage_name:\x20\"coop.rchain.models\"\nimport:\x20\"c\
    oop.rchain.models.BitSetBytesMapper.bitSetBytesMapper\"\nimport:\x20\"co\
    op.rchain.models.ParSetTypeMapper.parSetESetTypeMapper\"\nimport:\x20\"c\
    oop.rchain.models.ParMapTypeMapper.parMapEMapTypeMapper\"\npreserve_unkn\
    own_fields:\x20false\n};\n\n\n\n\x03\x04\0\x01\x12\x03%\x08\x0b\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03&\x04\x1c\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03&\
    \x04\x0c\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03&\r\x11\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03&\x12\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03&\x1a\x1b\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03'\x04\"\n\x0c\n\x05\x04\0\x02\x01\x04\
    \x12\x03'\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03'\r\x14\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03'\x15\x1d\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03'\x20!\n\x0b\n\x04\x04\0\x02\x02\x12\x03(\x04\x1a\n\x0c\n\x05\
    \x04\0\x02\x02\x04\x12\x03(\x04\x0c\n\x0c\n\x05\x04\0\x02\x02\x06\x12\
    \x03(\r\x10\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03(\x11\x15\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03(\x18\x19\n\x0b\n\x04\x04\0\x02\x03\x12\x03)\
    \x04\x1c\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\
    \0\x02\x03\x06\x12\x03)\r\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03)\x12\
    \x17\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03)\x1a\x1b\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03*\x04\x1f\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03*\x04\x0c\
    \n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03*\r\x12\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03*\x13\x1a\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03*\x1d\x1e\n\
    \x20\n\x04\x04\0\x02\x05\x12\x03+\x04+\"\x13\x20unforgeable\x20names\n\n\
    \x0c\n\x05\x04\0\x02\x05\x04\x12\x03+\x04\x0c\n\x0c\n\x05\x04\0\x02\x05\
    \x06\x12\x03+\r\x19\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03+\x1a&\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03+)*\n\x0b\n\x04\x04\0\x02\x06\x12\x03,\x04\
    !\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03,\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \x06\x06\x12\x03,\r\x13\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03,\x14\x1b\n\
    \x0c\n\x05\x04\0\x02\x06\x03\x12\x03,\x1e\x20\n\x0b\n\x04\x04\0\x02\x07\
    \x12\x03-\x04(\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03-\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x07\x06\x12\x03-\r\x17\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03-\x18#\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03-&'\nk\n\x04\x04\0\x02\
    \x08\x12\x03.\x04\x1b\"^[(scalapb.field).type\x20=\x20\"coop.rchain.mode\
    ls.AlwaysEqual[scala.collection.immutable.BitSet]\"];\n\n\x0c\n\x05\x04\
    \0\x02\x08\x05\x12\x03.\x04\t\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03.\n\
    \x15\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03.\x18\x19\n\x0b\n\x04\x04\0\
    \x02\t\x12\x03/\x04\x1e\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03/\x04\x08\n\
    \x0c\n\x05\x04\0\x02\t\x01\x12\x03/\t\x18\n\x0c\n\x05\x04\0\x02\t\x03\
    \x12\x03/\x1b\x1d\nH\n\x02\x04\x01\x12\x045\0:\x01\x1a<*\n\x20Either\x20\
    rholang\x20code\x20or\x20code\x20built\x20in\x20to\x20the\x20interpreter\
    .\n\n\n\n\x03\x04\x01\x01\x12\x035\x08\x1a\n\x0c\n\x04\x04\x01\x08\0\x12\
    \x046\x049\x05\n\x0c\n\x05\x04\x01\x08\0\x01\x12\x036\n\x15\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x037\x08#\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x037\x08\
    \x15\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x037\x16\x1e\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x037!\"\n\x0b\n\x04\x04\x01\x02\x01\x12\x038\x08!\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x038\x08\r\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x038\x0e\x1c\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x038\x1f\x20\n{\n\
    \x02\x04\x02\x12\x04@\0C\x01\x1ao*\n\x20Rholang\x20code\x20along\x20with\
    \x20the\x20state\x20of\x20a\x20split\x20random\x20number\n\x20generator\
    \x20for\x20generating\x20new\x20unforgeable\x20names.\n\n\n\n\x03\x04\
    \x02\x01\x12\x03@\x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03A\x04\x12\n\
    \x0c\n\x05\x04\x02\x02\0\x06\x12\x03A\x04\x07\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03A\x08\x0c\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03A\x0f\x10\nR\
    \n\x04\x04\x02\x02\x01\x12\x03B\x04\x1b\"E[(scalapb.field).type\x20=\x20\
    \"coop.rchain.crypto.hash.Blake2b512Random\"];\n\n\x0c\n\x05\x04\x02\x02\
    \x01\x05\x12\x03B\x04\t\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03B\n\x15\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03B\x18\x19\n1\n\x02\x04\x03\x12\x04\
    H\0J\x01\x1a%*\n\x20Cost\x20of\x20the\x20performed\x20operations.\n\n\n\
    \n\x03\x04\x03\x01\x12\x03H\x08\r\n\x0b\n\x04\x04\x03\x02\0\x12\x03I\x04\
    \x14\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03I\x04\n\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x03I\x0b\x0f\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03I\x12\
    \x13\n\n\n\x02\x04\x04\x12\x04L\0O\x01\n\n\n\x03\x04\x04\x01\x12\x03L\
    \x08\x19\n\x0b\n\x04\x04\x04\x02\0\x12\x03M\x04\x1a\n\x0c\n\x05\x04\x04\
    \x02\0\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03M\r\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03M\x11\x15\n\x0c\n\x05\x04\x04\x02\
    \0\x03\x12\x03M\x18\x19\nR\n\x04\x04\x04\x02\x01\x12\x03N\x04\x1b\"E[(sc\
    alapb.field).type\x20=\x20\"coop.rchain.crypto.hash.Blake2b512Random\"];\
    \n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03N\x04\t\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03N\n\x15\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03N\x18\
    \x19\n\xc1\x01\n\x02\x04\x05\x12\x04U\0\\\x01\x1a\xb4\x01\x20While\x20we\
    \x20use\x20vars\x20in\x20both\x20positions,\x20when\x20producing\x20the\
    \x20normalized\n\x20representation\x20we\x20need\x20a\x20discipline\x20t\
    o\x20track\x20whether\x20a\x20var\x20is\x20a\x20name\x20or\x20a\n\x20pro\
    cess.\n\x20These\x20are\x20DeBruijn\x20levels\n\n\n\n\x03\x04\x05\x01\
    \x12\x03U\x08\x0b\n\x0b\n\x04\x04\x05\x03\0\x12\x03V\x04\x1a\n\x0c\n\x05\
    \x04\x05\x03\0\x01\x12\x03V\x0c\x17\n\x0c\n\x04\x04\x05\x08\0\x12\x04W\
    \x04[\x05\n\x0c\n\x05\x04\x05\x08\0\x01\x12\x03W\n\x16\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03X\x08\x1d\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03X\x08\
    \x0e\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03X\x0f\x18\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03X\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x01\x12\x03Y\x08\x1c\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03Y\x08\x0e\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x03Y\x0f\x17\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03Y\
    \x1a\x1b\n\x0b\n\x04\x04\x05\x02\x02\x12\x03Z\x08!\n\x0c\n\x05\x04\x05\
    \x02\x02\x06\x12\x03Z\x08\x13\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03Z\
    \x14\x1c\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03Z\x1f\x20\n\xf0\x01\n\
    \x02\x04\x06\x12\x04d\0h\x01\x1a\xe3\x01*\n\x20Nothing\x20can\x20be\x20r\
    eceived\x20from\x20a\x20(quoted)\x20bundle\x20with\x20`readFlag\x20=\x20\
    false`.\n\x20Likeise\x20nothing\x20can\x20be\x20sent\x20to\x20a\x20(quot\
    ed)\x20bundle\x20with\x20`writeFlag\x20=\x20false`.\n\n\x20If\x20both\
    \x20flags\x20are\x20set\x20to\x20false,\x20bundle\x20allows\x20only\x20f\
    or\x20equivalance\x20check.\n\n\n\n\x03\x04\x06\x01\x12\x03d\x08\x0e\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03e\x04\x12\n\x0c\n\x05\x04\x06\x02\0\x06\
    \x12\x03e\x04\x07\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03e\x08\x0c\n\x0c\n\
    \x05\x04\x06\x02\0\x03\x12\x03e\x0f\x10\n:\n\x04\x04\x06\x02\x01\x12\x03\
    f\x04\x17\"-\x20flag\x20indicating\x20whether\x20bundle\x20is\x20writeab\
    le\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03f\x04\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03f\t\x12\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03f\
    \x15\x16\n9\n\x04\x04\x06\x02\x02\x12\x03g\x04\x16\",\x20flag\x20indicat\
    ing\x20whether\x20bundle\x20is\x20readable\n\n\x0c\n\x05\x04\x06\x02\x02\
    \x05\x12\x03g\x04\x08\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03g\t\x11\n\
    \x0c\n\x05\x04\x06\x02\x02\x03\x12\x03g\x14\x15\n\xa4\x01\n\x02\x04\x07\
    \x12\x04o\0u\x01\x1a\x97\x01*\n\x20A\x20send\x20is\x20written\x20`chan!(\
    data)`\x20or\x20`chan!!(data)`\x20for\x20a\x20persistent\x20send.\n\n\
    \x20Upon\x20send,\x20all\x20free\x20variables\x20in\x20data\x20are\x20su\
    bstituted\x20with\x20their\x20values.\n\n\n\n\x03\x04\x07\x01\x12\x03o\
    \x08\x0c\n\x0b\n\x04\x04\x07\x02\0\x12\x03p\x04\x12\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x03p\x04\x07\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03p\x08\
    \x0c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03p\x0f\x10\n\x0b\n\x04\x04\x07\
    \x02\x01\x12\x03q\x04\x1a\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03q\x04\
    \x0c\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03q\r\x10\n\x0c\n\x05\x04\x07\
    \x02\x01\x01\x12\x03q\x11\x15\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03q\
    \x18\x19\n\x0b\n\x04\x04\x07\x02\x02\x12\x03r\x04\x18\n\x0c\n\x05\x04\
    \x07\x02\x02\x05\x12\x03r\x04\x08\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\
    \x03r\t\x13\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03r\x16\x17\nk\n\x04\
    \x04\x07\x02\x03\x12\x03s\x04\x1b\"^[(scalapb.field).type\x20=\x20\"coop\
    .rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]\"];\n\n\
    \x0c\n\x05\x04\x07\x02\x03\x05\x12\x03s\x04\t\n\x0c\n\x05\x04\x07\x02\
    \x03\x01\x12\x03s\n\x15\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03s\x18\x19\
    \n\x0b\n\x04\x04\x07\x02\x04\x12\x03t\x04\x1d\n\x0c\n\x05\x04\x07\x02\
    \x04\x05\x12\x03t\x04\x08\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03t\t\x18\
    \n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03t\x1b\x1c\n\n\n\x02\x04\x08\x12\
    \x04w\0|\x01\n\n\n\x03\x04\x08\x01\x12\x03w\x08\x13\n\x0b\n\x04\x04\x08\
    \x02\0\x12\x03x\x04\x1e\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03x\x04\x0c\n\
    \x0c\n\x05\x04\x08\x02\0\x06\x12\x03x\r\x10\n\x0c\n\x05\x04\x08\x02\0\
    \x01\x12\x03x\x11\x19\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03x\x1c\x1d\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03y\x04\x14\n\x0c\n\x05\x04\x08\x02\x01\
    \x06\x12\x03y\x04\x07\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03y\x08\x0e\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x03y\x11\x12\n\x0b\n\x04\x04\x08\x02\
    \x02\x12\x03z\x04\x16\n\x0c\n\x05\x04\x08\x02\x02\x06\x12\x03z\x04\x07\n\
    \x0c\n\x05\x04\x08\x02\x02\x01\x12\x03z\x08\x11\n\x0c\n\x05\x04\x08\x02\
    \x02\x03\x12\x03z\x14\x15\n\x0b\n\x04\x04\x08\x02\x03\x12\x03{\x04\x18\n\
    \x0c\n\x05\x04\x08\x02\x03\x05\x12\x03{\x04\t\n\x0c\n\x05\x04\x08\x02\
    \x03\x01\x12\x03{\n\x13\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03{\x16\x17\
    \n\x0b\n\x02\x04\t\x12\x05~\0\x82\x01\x01\n\n\n\x03\x04\t\x01\x12\x03~\
    \x08\x13\n\x0b\n\x04\x04\t\x02\0\x12\x03\x7f\x04\x1e\n\x0c\n\x05\x04\t\
    \x02\0\x04\x12\x03\x7f\x04\x0c\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03\x7f\r\
    \x10\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03\x7f\x11\x19\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03\x7f\x1c\x1d\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x80\x01\
    \x04\x16\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\x80\x01\x04\x07\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\x80\x01\x08\x11\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\x80\x01\x14\x15\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x81\x01\x04\
    \x18\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x81\x01\x04\t\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\x81\x01\n\x13\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \x81\x01\x16\x17\n\x0c\n\x02\x04\n\x12\x06\x84\x01\0\x86\x01\x01\n\x0b\n\
    \x03\x04\n\x01\x12\x04\x84\x01\x08\x18\n\x0c\n\x04\x04\n\x02\0\x12\x04\
    \x85\x01\x04&\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x85\x01\x04\x0c\n\r\n\
    \x05\x04\n\x02\0\x06\x12\x04\x85\x01\r\x18\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\x85\x01\x19!\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x85\x01$%\n\xf0\x01\
    \n\x02\x04\x0b\x12\x06\x8f\x01\0\x97\x01\x01\x1a\xe1\x01*\n\x20A\x20rece\
    ive\x20is\x20written\x20`for(binds)\x20{\x20body\x20}`\n\x20i.e.\x20`for\
    (patterns\x20<-\x20source)\x20{\x20body\x20}`\n\x20or\x20for\x20a\x20per\
    sistent\x20recieve:\x20`for(patterns\x20<=\x20source)\x20{\x20body\x20}`\
    .\n\n\x20It's\x20an\x20error\x20for\x20free\x20Variable\x20to\x20occur\
    \x20more\x20than\x20once\x20in\x20a\x20pattern.\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\x8f\x01\x08\x0f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x90\x01\
    \x04#\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x90\x01\x04\x0c\n\r\n\x05\x04\
    \x0b\x02\0\x06\x12\x04\x90\x01\r\x18\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\
    \x90\x01\x19\x1e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x90\x01!\"\n\x0c\n\
    \x04\x04\x0b\x02\x01\x12\x04\x91\x01\x04\x12\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\x91\x01\x04\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x91\
    \x01\x08\x0c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x91\x01\x0f\x10\n\x0c\
    \n\x04\x04\x0b\x02\x02\x12\x04\x92\x01\x04\x18\n\r\n\x05\x04\x0b\x02\x02\
    \x05\x12\x04\x92\x01\x04\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x92\
    \x01\t\x13\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x92\x01\x16\x17\n\x0c\n\
    \x04\x04\x0b\x02\x03\x12\x04\x93\x01\x04\x12\n\r\n\x05\x04\x0b\x02\x03\
    \x05\x12\x04\x93\x01\x04\x08\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x93\
    \x01\t\r\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x93\x01\x10\x11\n\x0c\n\
    \x04\x04\x0b\x02\x04\x12\x04\x94\x01\x04\x18\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\x94\x01\x04\t\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x94\x01\
    \n\x13\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x94\x01\x16\x17\nl\n\x04\
    \x04\x0b\x02\x05\x12\x04\x95\x01\x04\x1b\"^[(scalapb.field).type\x20=\
    \x20\"coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]\
    \"];\n\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x95\x01\x04\t\n\r\n\x05\x04\
    \x0b\x02\x05\x01\x12\x04\x95\x01\n\x15\n\r\n\x05\x04\x0b\x02\x05\x03\x12\
    \x04\x95\x01\x18\x19\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x96\x01\x04\x1d\
    \n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\x96\x01\x04\x08\n\r\n\x05\x04\x0b\
    \x02\x06\x01\x12\x04\x96\x01\t\x18\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\
    \x96\x01\x1b\x1c\n\xfb\x01\n\x02\x04\x0c\x12\x06\x9d\x01\0\xa5\x01\x01\
    \x1a\xec\x01\x20Number\x20of\x20variables\x20bound\x20in\x20the\x20new\
    \x20statement.\n\x20For\x20normalized\x20form,\x20p\x20should\x20not\x20\
    contain\x20solely\x20another\x20new.\n\x20Also\x20for\x20normalized\x20f\
    orm,\x20the\x20first\x20use\x20should\x20be\x20level+0,\x20next\x20use\
    \x20level+1\n\x20up\x20to\x20level+count\x20for\x20the\x20last\x20used\
    \x20variable.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x9d\x01\x08\x0b\nb\n\x04\
    \x04\x0c\x02\0\x12\x04\x9f\x01\x04\x19\x1aT\x20Includes\x20any\x20uris\
    \x20listed\x20below.\x20This\x20makes\x20it\x20easier\x20to\x20substitut\
    e\x20or\x20walk\x20a\x20term.\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x9f\
    \x01\x04\n\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x9f\x01\x0b\x14\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x9f\x01\x17\x18\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\xa0\x01\x04\x0f\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xa0\x01\
    \x04\x07\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa0\x01\x08\t\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\xa0\x01\x0c\r\nj\n\x04\x04\x0c\x02\x02\x12\
    \x04\xa2\x01\x04\x1c\x1a\\\x20For\x20normalization,\x20uri-referenced\
    \x20variables\x20come\x20at\x20the\x20end,\x20and\x20in\x20lexicographic\
    al\x20order.\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xa2\x01\x04\x0c\n\r\
    \n\x05\x04\x0c\x02\x02\x05\x12\x04\xa2\x01\r\x13\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\xa2\x01\x14\x17\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\
    \xa2\x01\x1a\x1b\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xa3\x01\x04$\n\r\n\
    \x05\x04\x0c\x02\x03\x06\x12\x04\xa3\x01\x04\x14\n\r\n\x05\x04\x0c\x02\
    \x03\x01\x12\x04\xa3\x01\x15\x1f\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\
    \xa3\x01\"#\nl\n\x04\x04\x0c\x02\x04\x12\x04\xa4\x01\x04\x1b\"^[(scalapb\
    .field).type\x20=\x20\"coop.rchain.models.AlwaysEqual[scala.collection.i\
    mmutable.BitSet]\"];\n\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\xa4\x01\x04\
    \t\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xa4\x01\n\x15\n\r\n\x05\x04\x0c\
    \x02\x04\x03\x12\x04\xa4\x01\x18\x19\n\x0c\n\x02\x04\r\x12\x06\xa7\x01\0\
    \xab\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xa7\x01\x08\x11\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\xa8\x01\x04\x15\n\r\n\x05\x04\r\x02\0\x06\x12\x04\
    \xa8\x01\x04\x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa8\x01\x08\x0f\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xa8\x01\x12\x13\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\xa9\x01\x04\x14\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xa9\x01\x04\
    \x07\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa9\x01\x08\x0e\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\xa9\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x02\x12\x04\
    \xaa\x01\x04\x18\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xaa\x01\x04\t\n\r\n\
    \x05\x04\r\x02\x02\x01\x12\x04\xaa\x01\n\x13\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\xaa\x01\x16\x17\n\x0c\n\x02\x04\x0e\x12\x06\xad\x01\0\xb2\x01\
    \x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xad\x01\x08\r\n\x0c\n\x04\x04\x0e\
    \x02\0\x12\x04\xae\x01\x04\x14\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xae\
    \x01\x04\x07\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xae\x01\x08\x0e\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xae\x01\x11\x12\n\x0c\n\x04\x04\x0e\x02\
    \x01\x12\x04\xaf\x01\x04!\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xaf\x01\
    \x04\x0c\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xaf\x01\r\x16\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\xaf\x01\x17\x1c\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xaf\x01\x1f\x20\nl\n\x04\x04\x0e\x02\x02\x12\x04\xb0\x01\
    \x04\x1b\"^[(scalapb.field).type\x20=\x20\"coop.rchain.models.AlwaysEqua\
    l[scala.collection.immutable.BitSet]\"];\n\n\r\n\x05\x04\x0e\x02\x02\x05\
    \x12\x04\xb0\x01\x04\t\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xb0\x01\n\
    \x15\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xb0\x01\x18\x19\n\x0c\n\x04\
    \x04\x0e\x02\x03\x12\x04\xb1\x01\x04\x1d\n\r\n\x05\x04\x0e\x02\x03\x05\
    \x12\x04\xb1\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xb1\x01\t\
    \x18\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xb1\x01\x1b\x1c\n\x8f\x01\n\
    \x02\x04\x0f\x12\x06\xb6\x01\0\xdb\x01\x01\x1a\x80\x01\x20Any\x20process\
    \x20may\x20be\x20an\x20operand\x20to\x20an\x20expression.\n\x20Only\x20p\
    rocesses\x20equivalent\x20to\x20a\x20ground\x20process\x20of\x20compatib\
    le\x20type\x20will\x20reduce.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb6\x01\
    \x08\x0c\n\x0e\n\x04\x04\x0f\x08\0\x12\x06\xb7\x01\x04\xda\x01\x05\n\r\n\
    \x05\x04\x0f\x08\0\x01\x12\x04\xb7\x01\n\x17\n\x0c\n\x04\x04\x0f\x02\0\
    \x12\x04\xb8\x01\x08\x18\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xb8\x01\x08\
    \x0c\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb8\x01\r\x13\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xb8\x01\x16\x17\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \xb9\x01\x08\x19\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xb9\x01\x08\x0e\n\
    \r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb9\x01\x0f\x14\n\r\n\x05\x04\x0f\
    \x02\x01\x03\x12\x04\xb9\x01\x17\x18\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\
    \xba\x01\x08\x1c\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xba\x01\x08\x0e\n\
    \r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xba\x01\x0f\x17\n\r\n\x05\x04\x0f\
    \x02\x02\x03\x12\x04\xba\x01\x1a\x1b\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\
    \xbb\x01\x08\x19\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\xbb\x01\x08\x0e\n\
    \r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xbb\x01\x0f\x14\n\r\n\x05\x04\x0f\
    \x02\x03\x03\x12\x04\xbb\x01\x17\x18\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\
    \xbc\x01\x08\x20\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xbc\x01\x08\r\n\r\
    \n\x05\x04\x0f\x02\x04\x01\x12\x04\xbc\x01\x0e\x1a\n\r\n\x05\x04\x0f\x02\
    \x04\x03\x12\x04\xbc\x01\x1d\x1f\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xbe\
    \x01\x08\x1c\n\r\n\x05\x04\x0f\x02\x05\x06\x12\x04\xbe\x01\x08\x0c\n\r\n\
    \x05\x04\x0f\x02\x05\x01\x12\x04\xbe\x01\r\x17\n\r\n\x05\x04\x0f\x02\x05\
    \x03\x12\x04\xbe\x01\x1a\x1b\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xbf\x01\
    \x08\x1c\n\r\n\x05\x04\x0f\x02\x06\x06\x12\x04\xbf\x01\x08\x0c\n\r\n\x05\
    \x04\x0f\x02\x06\x01\x12\x04\xbf\x01\r\x17\n\r\n\x05\x04\x0f\x02\x06\x03\
    \x12\x04\xbf\x01\x1a\x1b\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\xc0\x01\x08\
    \x1e\n\r\n\x05\x04\x0f\x02\x07\x06\x12\x04\xc0\x01\x08\r\n\r\n\x05\x04\
    \x0f\x02\x07\x01\x12\x04\xc0\x01\x0e\x19\n\r\n\x05\x04\x0f\x02\x07\x03\
    \x12\x04\xc0\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\xc1\x01\x08\
    \x1c\n\r\n\x05\x04\x0f\x02\x08\x06\x12\x04\xc1\x01\x08\x0c\n\r\n\x05\x04\
    \x0f\x02\x08\x01\x12\x04\xc1\x01\r\x17\n\r\n\x05\x04\x0f\x02\x08\x03\x12\
    \x04\xc1\x01\x1a\x1b\n\x0c\n\x04\x04\x0f\x02\t\x12\x04\xc2\x01\x08\x1e\n\
    \r\n\x05\x04\x0f\x02\t\x06\x12\x04\xc2\x01\x08\r\n\r\n\x05\x04\x0f\x02\t\
    \x01\x12\x04\xc2\x01\x0e\x19\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\xc2\x01\
    \x1c\x1d\n\x0c\n\x04\x04\x0f\x02\n\x12\x04\xc3\x01\x08!\n\r\n\x05\x04\
    \x0f\x02\n\x06\x12\x04\xc3\x01\x08\x0e\n\r\n\x05\x04\x0f\x02\n\x01\x12\
    \x04\xc3\x01\x0f\x1b\n\r\n\x05\x04\x0f\x02\n\x03\x12\x04\xc3\x01\x1e\x20\
    \n\x0c\n\x04\x04\x0f\x02\x0b\x12\x04\xc4\x01\x08\x1b\n\r\n\x05\x04\x0f\
    \x02\x0b\x06\x12\x04\xc4\x01\x08\x0b\n\r\n\x05\x04\x0f\x02\x0b\x01\x12\
    \x04\xc4\x01\x0c\x15\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\x04\xc4\x01\x18\
    \x1a\n\x0c\n\x04\x04\x0f\x02\x0c\x12\x04\xc5\x01\x08\x1d\n\r\n\x05\x04\
    \x0f\x02\x0c\x06\x12\x04\xc5\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x0c\x01\
    \x12\x04\xc5\x01\r\x17\n\r\n\x05\x04\x0f\x02\x0c\x03\x12\x04\xc5\x01\x1a\
    \x1c\n\x0c\n\x04\x04\x0f\x02\r\x12\x04\xc6\x01\x08\x1b\n\r\n\x05\x04\x0f\
    \x02\r\x06\x12\x04\xc6\x01\x08\x0b\n\r\n\x05\x04\x0f\x02\r\x01\x12\x04\
    \xc6\x01\x0c\x15\n\r\n\x05\x04\x0f\x02\r\x03\x12\x04\xc6\x01\x18\x1a\n\
    \x0c\n\x04\x04\x0f\x02\x0e\x12\x04\xc7\x01\x08\x1d\n\r\n\x05\x04\x0f\x02\
    \x0e\x06\x12\x04\xc7\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x0e\x01\x12\x04\
    \xc7\x01\r\x17\n\r\n\x05\x04\x0f\x02\x0e\x03\x12\x04\xc7\x01\x1a\x1c\n\
    \x0c\n\x04\x04\x0f\x02\x0f\x12\x04\xc8\x01\x08\x1b\n\r\n\x05\x04\x0f\x02\
    \x0f\x06\x12\x04\xc8\x01\x08\x0b\n\r\n\x05\x04\x0f\x02\x0f\x01\x12\x04\
    \xc8\x01\x0c\x15\n\r\n\x05\x04\x0f\x02\x0f\x03\x12\x04\xc8\x01\x18\x1a\n\
    \x0c\n\x04\x04\x0f\x02\x10\x12\x04\xc9\x01\x08\x1d\n\r\n\x05\x04\x0f\x02\
    \x10\x06\x12\x04\xc9\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x10\x01\x12\x04\
    \xc9\x01\r\x17\n\r\n\x05\x04\x0f\x02\x10\x03\x12\x04\xc9\x01\x1a\x1c\n\
    \x0c\n\x04\x04\x0f\x02\x11\x12\x04\xca\x01\x08\x1d\n\r\n\x05\x04\x0f\x02\
    \x11\x06\x12\x04\xca\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x11\x01\x12\x04\
    \xca\x01\r\x17\n\r\n\x05\x04\x0f\x02\x11\x03\x12\x04\xca\x01\x1a\x1c\n\
    \x0c\n\x04\x04\x0f\x02\x12\x12\x04\xcb\x01\x08\x1b\n\r\n\x05\x04\x0f\x02\
    \x12\x06\x12\x04\xcb\x01\x08\x0b\n\r\n\x05\x04\x0f\x02\x12\x01\x12\x04\
    \xcb\x01\x0c\x15\n\r\n\x05\x04\x0f\x02\x12\x03\x12\x04\xcb\x01\x18\x1a\n\
    \x0c\n\x04\x04\x0f\x02\x13\x12\x04\xcc\x01\x08\x1d\n\r\n\x05\x04\x0f\x02\
    \x13\x06\x12\x04\xcc\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x13\x01\x12\x04\
    \xcc\x01\r\x17\n\r\n\x05\x04\x0f\x02\x13\x03\x12\x04\xcc\x01\x1a\x1c\n\
    \x0c\n\x04\x04\x0f\x02\x14\x12\x04\xce\x01\x08\x1f\n\r\n\x05\x04\x0f\x02\
    \x14\x06\x12\x04\xce\x01\x08\r\n\r\n\x05\x04\x0f\x02\x14\x01\x12\x04\xce\
    \x01\x0e\x19\n\r\n\x05\x04\x0f\x02\x14\x03\x12\x04\xce\x01\x1c\x1e\n\x0c\
    \n\x04\x04\x0f\x02\x15\x12\x04\xcf\x01\x08!\n\r\n\x05\x04\x0f\x02\x15\
    \x06\x12\x04\xcf\x01\x08\x0e\n\r\n\x05\x04\x0f\x02\x15\x01\x12\x04\xcf\
    \x01\x0f\x1b\n\r\n\x05\x04\x0f\x02\x15\x03\x12\x04\xcf\x01\x1e\x20\nD\n\
    \x04\x04\x0f\x02\x16\x12\x04\xd0\x01\x08\x1e\"6[(scalapb.field).type\x20\
    =\x20\"coop.rchain.models.ParSet\"];\n\n\r\n\x05\x04\x0f\x02\x16\x06\x12\
    \x04\xd0\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\x16\x01\x12\x04\xd0\x01\r\x17\
    \n\r\n\x05\x04\x0f\x02\x16\x03\x12\x04\xd0\x01\x1a\x1c\nD\n\x04\x04\x0f\
    \x02\x17\x12\x04\xd1\x01\x08\x1e\"6[(scalapb.field).type\x20=\x20\"coop.\
    rchain.models.ParMap\"];\n\n\r\n\x05\x04\x0f\x02\x17\x06\x12\x04\xd1\x01\
    \x08\x0c\n\r\n\x05\x04\x0f\x02\x17\x01\x12\x04\xd1\x01\r\x17\n\r\n\x05\
    \x04\x0f\x02\x17\x03\x12\x04\xd1\x01\x1a\x1c\n\x0c\n\x04\x04\x0f\x02\x18\
    \x12\x04\xd2\x01\x08#\n\r\n\x05\x04\x0f\x02\x18\x06\x12\x04\xd2\x01\x08\
    \x0f\n\r\n\x05\x04\x0f\x02\x18\x01\x12\x04\xd2\x01\x10\x1d\n\r\n\x05\x04\
    \x0f\x02\x18\x03\x12\x04\xd2\x01\x20\"\n\x0c\n\x04\x04\x0f\x02\x19\x12\
    \x04\xd4\x01\x08%\n\r\n\x05\x04\x0f\x02\x19\x06\x12\x04\xd4\x01\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x19\x01\x12\x04\xd4\x01\x11\x1f\n\r\n\x05\x04\x0f\
    \x02\x19\x03\x12\x04\xd4\x01\"$\n$\n\x04\x04\x0f\x02\x1a\x12\x04\xd5\x01\
    \x084\"\x16\x20string\x20interpolation\n\n\r\n\x05\x04\x0f\x02\x1a\x06\
    \x12\x04\xd5\x01\x08\x17\n\r\n\x05\x04\x0f\x02\x1a\x01\x12\x04\xd5\x01\
    \x18.\n\r\n\x05\x04\x0f\x02\x1a\x03\x12\x04\xd5\x0113\n\x1d\n\x04\x04\
    \x0f\x02\x1b\x12\x04\xd6\x01\x08(\"\x0f\x20concatenation\n\n\r\n\x05\x04\
    \x0f\x02\x1b\x06\x12\x04\xd6\x01\x08\x11\n\r\n\x05\x04\x0f\x02\x1b\x01\
    \x12\x04\xd6\x01\x12\"\n\r\n\x05\x04\x0f\x02\x1b\x03\x12\x04\xd6\x01%'\n\
    \x1e\n\x04\x04\x0f\x02\x1c\x12\x04\xd7\x01\x08,\"\x10\x20set\x20differen\
    ce\n\n\r\n\x05\x04\x0f\x02\x1c\x06\x12\x04\xd7\x01\x08\x13\n\r\n\x05\x04\
    \x0f\x02\x1c\x01\x12\x04\xd7\x01\x14&\n\r\n\x05\x04\x0f\x02\x1c\x03\x12\
    \x04\xd7\x01)+\n\x0c\n\x04\x04\x0f\x02\x1d\x12\x04\xd9\x01\x08\x1d\n\r\n\
    \x05\x04\x0f\x02\x1d\x06\x12\x04\xd9\x01\x08\x0c\n\r\n\x05\x04\x0f\x02\
    \x1d\x01\x12\x04\xd9\x01\r\x17\n\r\n\x05\x04\x0f\x02\x1d\x03\x12\x04\xd9\
    \x01\x1a\x1c\n\x0c\n\x02\x04\x10\x12\x06\xdd\x01\0\xe2\x01\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xdd\x01\x08\r\n\x0c\n\x04\x04\x10\x02\0\x12\x04\
    \xde\x01\x04\x18\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xde\x01\x04\x0c\n\r\
    \n\x05\x04\x10\x02\0\x06\x12\x04\xde\x01\r\x10\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\xde\x01\x11\x13\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xde\x01\
    \x16\x17\nl\n\x04\x04\x10\x02\x01\x12\x04\xdf\x01\x04\x1b\"^[(scalapb.fi\
    eld).type\x20=\x20\"coop.rchain.models.AlwaysEqual[scala.collection.immu\
    table.BitSet]\"];\n\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xdf\x01\x04\t\
    \n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xdf\x01\n\x15\n\r\n\x05\x04\x10\
    \x02\x01\x03\x12\x04\xdf\x01\x18\x19\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\
    \xe0\x01\x04\x1d\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xe0\x01\x04\x08\n\
    \r\n\x05\x04\x10\x02\x02\x01\x12\x04\xe0\x01\t\x18\n\r\n\x05\x04\x10\x02\
    \x02\x03\x12\x04\xe0\x01\x1b\x1c\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xe1\
    \x01\x04\x16\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\xe1\x01\x04\x07\n\r\n\
    \x05\x04\x10\x02\x03\x01\x12\x04\xe1\x01\x08\x11\n\r\n\x05\x04\x10\x02\
    \x03\x03\x12\x04\xe1\x01\x14\x15\n\x0c\n\x02\x04\x11\x12\x06\xe4\x01\0\
    \xe8\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xe4\x01\x08\x0e\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\xe5\x01\x04\x18\n\r\n\x05\x04\x11\x02\0\x04\x12\
    \x04\xe5\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xe5\x01\r\x10\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xe5\x01\x11\x13\n\r\n\x05\x04\x11\x02\
    \0\x03\x12\x04\xe5\x01\x16\x17\nl\n\x04\x04\x11\x02\x01\x12\x04\xe6\x01\
    \x04\x1b\"^[(scalapb.field).type\x20=\x20\"coop.rchain.models.AlwaysEqua\
    l[scala.collection.immutable.BitSet]\"];\n\n\r\n\x05\x04\x11\x02\x01\x05\
    \x12\x04\xe6\x01\x04\t\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe6\x01\n\
    \x15\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe6\x01\x18\x19\n\x0c\n\x04\
    \x04\x11\x02\x02\x12\x04\xe7\x01\x04\x1d\n\r\n\x05\x04\x11\x02\x02\x05\
    \x12\x04\xe7\x01\x04\x08\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe7\x01\t\
    \x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xe7\x01\x1b\x1c\n\x0c\n\x02\
    \x04\x12\x12\x06\xea\x01\0\xef\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xea\x01\x08\x0c\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xeb\x01\x04\x18\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04\xeb\x01\x04\x0c\n\r\n\x05\x04\x12\x02\0\
    \x06\x12\x04\xeb\x01\r\x10\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xeb\x01\
    \x11\x13\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xeb\x01\x16\x17\nl\n\x04\
    \x04\x12\x02\x01\x12\x04\xec\x01\x04\x1b\"^[(scalapb.field).type\x20=\
    \x20\"coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]\
    \"];\n\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xec\x01\x04\t\n\r\n\x05\x04\
    \x12\x02\x01\x01\x12\x04\xec\x01\n\x15\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\xec\x01\x18\x19\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xed\x01\x04\x1d\
    \n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xed\x01\x04\x08\n\r\n\x05\x04\x12\
    \x02\x02\x01\x12\x04\xed\x01\t\x18\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\
    \xed\x01\x1b\x1c\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xee\x01\x04\x16\n\r\
    \n\x05\x04\x12\x02\x03\x06\x12\x04\xee\x01\x04\x07\n\r\n\x05\x04\x12\x02\
    \x03\x01\x12\x04\xee\x01\x08\x11\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\
    \xee\x01\x14\x15\n\x0c\n\x02\x04\x13\x12\x06\xf1\x01\0\xf6\x01\x01\n\x0b\
    \n\x03\x04\x13\x01\x12\x04\xf1\x01\x08\x0c\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\xf2\x01\x04\"\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xf2\x01\x04\x0c\n\
    \r\n\x05\x04\x13\x02\0\x06\x12\x04\xf2\x01\r\x19\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xf2\x01\x1a\x1d\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf2\x01\
    \x20!\nl\n\x04\x04\x13\x02\x01\x12\x04\xf3\x01\x04\x1b\"^[(scalapb.field\
    ).type\x20=\x20\"coop.rchain.models.AlwaysEqual[scala.collection.immutab\
    le.BitSet]\"];\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xf3\x01\x04\t\n\r\
    \n\x05\x04\x13\x02\x01\x01\x12\x04\xf3\x01\n\x15\n\r\n\x05\x04\x13\x02\
    \x01\x03\x12\x04\xf3\x01\x18\x19\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xf4\
    \x01\x04\x1d\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xf4\x01\x04\x08\n\r\n\
    \x05\x04\x13\x02\x02\x01\x12\x04\xf4\x01\t\x18\n\r\n\x05\x04\x13\x02\x02\
    \x03\x12\x04\xf4\x01\x1b\x1c\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xf5\x01\
    \x04\x16\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xf5\x01\x04\x07\n\r\n\x05\
    \x04\x13\x02\x03\x01\x12\x04\xf5\x01\x08\x11\n\r\n\x05\x04\x13\x02\x03\
    \x03\x12\x04\xf5\x01\x14\x15\n,\n\x02\x04\x14\x12\x06\xfb\x01\0\x81\x02\
    \x01\x1a\x1e*\n\x20`target.method(arguments)`\n\n\x0b\n\x03\x04\x14\x01\
    \x12\x04\xfb\x01\x08\x0f\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xfc\x01\x04\
    \x1a\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xfc\x01\x04\n\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xfc\x01\x0b\x15\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xfc\x01\x18\x19\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xfd\x01\x04\x14\n\r\
    \n\x05\x04\x14\x02\x01\x06\x12\x04\xfd\x01\x04\x07\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xfd\x01\x08\x0e\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xfd\x01\x11\x12\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xfe\x01\x04\x1f\n\r\
    \n\x05\x04\x14\x02\x02\x04\x12\x04\xfe\x01\x04\x0c\n\r\n\x05\x04\x14\x02\
    \x02\x06\x12\x04\xfe\x01\r\x10\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xfe\
    \x01\x11\x1a\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xfe\x01\x1d\x1e\nl\n\
    \x04\x04\x14\x02\x03\x12\x04\xff\x01\x04\x1b\"^[(scalapb.field).type\x20\
    =\x20\"coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]\
    \"];\n\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xff\x01\x04\t\n\r\n\x05\x04\
    \x14\x02\x03\x01\x12\x04\xff\x01\n\x15\n\r\n\x05\x04\x14\x02\x03\x03\x12\
    \x04\xff\x01\x18\x19\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\x80\x02\x04\x1d\
    \n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\x80\x02\x04\x08\n\r\n\x05\x04\x14\
    \x02\x04\x01\x12\x04\x80\x02\t\x18\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\
    \x80\x02\x1b\x1c\n\x0c\n\x02\x04\x15\x12\x06\x83\x02\0\x86\x02\x01\n\x0b\
    \n\x03\x04\x15\x01\x12\x04\x83\x02\x08\x14\n\x0c\n\x04\x04\x15\x02\0\x12\
    \x04\x84\x02\x04\x11\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x84\x02\x04\x07\
    \n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x84\x02\x08\x0b\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\x84\x02\x0e\x0f\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \x85\x02\x04\x13\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\x85\x02\x04\x07\n\
    \r\n\x05\x04\x15\x02\x01\x01\x12\x04\x85\x02\x08\r\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\x85\x02\x10\x11\n\xe7\x01\n\x02\x04\x16\x12\x06\x8c\x02\
    \0\x8e\x02\x01\x1a\xd8\x01\x20A\x20variable\x20used\x20as\x20a\x20var\
    \x20should\x20be\x20bound\x20in\x20a\x20process\x20context,\x20not\x20a\
    \x20name\n\x20context.\x20For\x20example:\n\x20`for\x20(@x\x20<-\x20c1;\
    \x20@y\x20<-\x20c2)\x20{\x20z!(x\x20+\x20y)\x20}`\x20is\x20fine,\x20but\
    \n\x20`for\x20(x\x20<-\x20c1;\x20y\x20<-\x20c2)\x20{\x20z!(x\x20+\x20y)\
    \x20}`\x20should\x20raise\x20an\x20error.\n\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x8c\x02\x08\x0c\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x8d\x02\x04\x0f\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\x8d\x02\x04\x07\n\r\n\x05\x04\x16\x02\
    \0\x01\x12\x04\x8d\x02\x08\t\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x8d\x02\
    \x0c\r\n\x0c\n\x02\x04\x17\x12\x06\x90\x02\0\x92\x02\x01\n\x0b\n\x03\x04\
    \x17\x01\x12\x04\x90\x02\x08\x0c\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x91\
    \x02\x04\x0f\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x91\x02\x04\x07\n\r\n\
    \x05\x04\x17\x02\0\x01\x12\x04\x91\x02\x08\t\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\x91\x02\x0c\r\n\x0c\n\x02\x04\x18\x12\x06\x94\x02\0\x96\x02\x01\
    \n\x0b\n\x03\x04\x18\x01\x12\x04\x94\x02\x08\x0c\n\x0c\n\x04\x04\x18\x02\
    \0\x12\x04\x95\x02\x04\x0f\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x95\x02\
    \x04\x07\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x95\x02\x08\t\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\x95\x02\x0c\r\n\x0c\n\x02\x04\x19\x12\x06\x98\x02\
    \0\x9b\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\x98\x02\x08\r\n\x0c\n\x04\
    \x04\x19\x02\0\x12\x04\x99\x02\x04\x10\n\r\n\x05\x04\x19\x02\0\x06\x12\
    \x04\x99\x02\x04\x07\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x99\x02\x08\n\n\
    \r\n\x05\x04\x19\x02\0\x03\x12\x04\x99\x02\r\x0e\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\x9a\x02\x04\x10\n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\x9a\
    \x02\x04\x07\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\x9a\x02\x08\n\n\r\n\
    \x05\x04\x19\x02\x01\x03\x12\x04\x9a\x02\r\x0e\n\x0c\n\x02\x04\x1a\x12\
    \x06\x9d\x02\0\xa0\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x9d\x02\x08\
    \x0c\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x9e\x02\x04\x10\n\r\n\x05\x04\x1a\
    \x02\0\x06\x12\x04\x9e\x02\x04\x07\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\
    \x9e\x02\x08\n\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x9e\x02\r\x0e\n\x0c\n\
    \x04\x04\x1a\x02\x01\x12\x04\x9f\x02\x04\x10\n\r\n\x05\x04\x1a\x02\x01\
    \x06\x12\x04\x9f\x02\x04\x07\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\x9f\
    \x02\x08\n\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x9f\x02\r\x0e\n\x0c\n\
    \x02\x04\x1b\x12\x06\xa2\x02\0\xa5\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xa2\x02\x08\x0c\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xa3\x02\x04\x10\n\
    \r\n\x05\x04\x1b\x02\0\x06\x12\x04\xa3\x02\x04\x07\n\r\n\x05\x04\x1b\x02\
    \0\x01\x12\x04\xa3\x02\x08\n\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xa3\x02\
    \r\x0e\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xa4\x02\x04\x10\n\r\n\x05\x04\
    \x1b\x02\x01\x06\x12\x04\xa4\x02\x04\x07\n\r\n\x05\x04\x1b\x02\x01\x01\
    \x12\x04\xa4\x02\x08\n\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xa4\x02\r\
    \x0e\n\x0c\n\x02\x04\x1c\x12\x06\xa7\x02\0\xaa\x02\x01\n\x0b\n\x03\x04\
    \x1c\x01\x12\x04\xa7\x02\x08\r\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xa8\x02\
    \x04\x10\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xa8\x02\x04\x07\n\r\n\x05\
    \x04\x1c\x02\0\x01\x12\x04\xa8\x02\x08\n\n\r\n\x05\x04\x1c\x02\0\x03\x12\
    \x04\xa8\x02\r\x0e\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xa9\x02\x04\x10\n\
    \r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xa9\x02\x04\x07\n\r\n\x05\x04\x1c\
    \x02\x01\x01\x12\x04\xa9\x02\x08\n\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\
    \xa9\x02\r\x0e\n\x0c\n\x02\x04\x1d\x12\x06\xac\x02\0\xaf\x02\x01\n\x0b\n\
    \x03\x04\x1d\x01\x12\x04\xac\x02\x08\x0e\n\x0c\n\x04\x04\x1d\x02\0\x12\
    \x04\xad\x02\x04\x10\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xad\x02\x04\x07\
    \n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xad\x02\x08\n\n\r\n\x05\x04\x1d\x02\
    \0\x03\x12\x04\xad\x02\r\x0e\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xae\x02\
    \x04\x10\n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\xae\x02\x04\x07\n\r\n\x05\
    \x04\x1d\x02\x01\x01\x12\x04\xae\x02\x08\n\n\r\n\x05\x04\x1d\x02\x01\x03\
    \x12\x04\xae\x02\r\x0e\n\x0c\n\x02\x04\x1e\x12\x06\xb1\x02\0\xb4\x02\x01\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\xb1\x02\x08\x0b\n\x0c\n\x04\x04\x1e\x02\
    \0\x12\x04\xb2\x02\x04\x10\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xb2\x02\
    \x04\x07\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb2\x02\x08\n\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xb2\x02\r\x0e\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\
    \xb3\x02\x04\x10\n\r\n\x05\x04\x1e\x02\x01\x06\x12\x04\xb3\x02\x04\x07\n\
    \r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xb3\x02\x08\n\n\r\n\x05\x04\x1e\x02\
    \x01\x03\x12\x04\xb3\x02\r\x0e\n\x0c\n\x02\x04\x1f\x12\x06\xb6\x02\0\xb9\
    \x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xb6\x02\x08\x0c\n\x0c\n\x04\x04\
    \x1f\x02\0\x12\x04\xb7\x02\x04\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\
    \xb7\x02\x04\x07\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xb7\x02\x08\n\n\r\n\
    \x05\x04\x1f\x02\0\x03\x12\x04\xb7\x02\r\x0e\n\x0c\n\x04\x04\x1f\x02\x01\
    \x12\x04\xb8\x02\x04\x10\n\r\n\x05\x04\x1f\x02\x01\x06\x12\x04\xb8\x02\
    \x04\x07\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xb8\x02\x08\n\n\r\n\x05\
    \x04\x1f\x02\x01\x03\x12\x04\xb8\x02\r\x0e\n\x0c\n\x02\x04\x20\x12\x06\
    \xbb\x02\0\xbe\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xbb\x02\x08\x0b\n\
    \x0c\n\x04\x04\x20\x02\0\x12\x04\xbc\x02\x04\x10\n\r\n\x05\x04\x20\x02\0\
    \x06\x12\x04\xbc\x02\x04\x07\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xbc\x02\
    \x08\n\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xbc\x02\r\x0e\n\x0c\n\x04\x04\
    \x20\x02\x01\x12\x04\xbd\x02\x04\x10\n\r\n\x05\x04\x20\x02\x01\x06\x12\
    \x04\xbd\x02\x04\x07\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xbd\x02\x08\n\
    \n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xbd\x02\r\x0e\n\x0c\n\x02\x04!\
    \x12\x06\xc0\x02\0\xc3\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\xc0\x02\x08\
    \x0c\n\x0c\n\x04\x04!\x02\0\x12\x04\xc1\x02\x04\x10\n\r\n\x05\x04!\x02\0\
    \x06\x12\x04\xc1\x02\x04\x07\n\r\n\x05\x04!\x02\0\x01\x12\x04\xc1\x02\
    \x08\n\n\r\n\x05\x04!\x02\0\x03\x12\x04\xc1\x02\r\x0e\n\x0c\n\x04\x04!\
    \x02\x01\x12\x04\xc2\x02\x04\x10\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xc2\
    \x02\x04\x07\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xc2\x02\x08\n\n\r\n\x05\
    \x04!\x02\x01\x03\x12\x04\xc2\x02\r\x0e\n\x0c\n\x02\x04\"\x12\x06\xc5\
    \x02\0\xc8\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xc5\x02\x08\x0b\n\x0c\n\
    \x04\x04\"\x02\0\x12\x04\xc6\x02\x04\x10\n\r\n\x05\x04\"\x02\0\x06\x12\
    \x04\xc6\x02\x04\x07\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xc6\x02\x08\n\n\r\
    \n\x05\x04\"\x02\0\x03\x12\x04\xc6\x02\r\x0e\n\x0c\n\x04\x04\"\x02\x01\
    \x12\x04\xc7\x02\x04\x10\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xc7\x02\x04\
    \x07\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xc7\x02\x08\n\n\r\n\x05\x04\"\
    \x02\x01\x03\x12\x04\xc7\x02\r\x0e\n\x0c\n\x02\x04#\x12\x06\xca\x02\0\
    \xcd\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xca\x02\x08\x0c\n\x0c\n\x04\
    \x04#\x02\0\x12\x04\xcb\x02\x04\x10\n\r\n\x05\x04#\x02\0\x06\x12\x04\xcb\
    \x02\x04\x07\n\r\n\x05\x04#\x02\0\x01\x12\x04\xcb\x02\x08\n\n\r\n\x05\
    \x04#\x02\0\x03\x12\x04\xcb\x02\r\x0e\n\x0c\n\x04\x04#\x02\x01\x12\x04\
    \xcc\x02\x04\x10\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xcc\x02\x04\x07\n\r\
    \n\x05\x04#\x02\x01\x01\x12\x04\xcc\x02\x08\n\n\r\n\x05\x04#\x02\x01\x03\
    \x12\x04\xcc\x02\r\x0e\n\x0c\n\x02\x04$\x12\x06\xcf\x02\0\xd2\x02\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\xcf\x02\x08\x0c\n\x0c\n\x04\x04$\x02\0\x12\
    \x04\xd0\x02\x04\x10\n\r\n\x05\x04$\x02\0\x06\x12\x04\xd0\x02\x04\x07\n\
    \r\n\x05\x04$\x02\0\x01\x12\x04\xd0\x02\x08\n\n\r\n\x05\x04$\x02\0\x03\
    \x12\x04\xd0\x02\r\x0e\n\x0c\n\x04\x04$\x02\x01\x12\x04\xd1\x02\x04\x10\
    \n\r\n\x05\x04$\x02\x01\x06\x12\x04\xd1\x02\x04\x07\n\r\n\x05\x04$\x02\
    \x01\x01\x12\x04\xd1\x02\x08\n\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xd1\
    \x02\r\x0e\n\x0c\n\x02\x04%\x12\x06\xd4\x02\0\xd7\x02\x01\n\x0b\n\x03\
    \x04%\x01\x12\x04\xd4\x02\x08\x0b\n\x0c\n\x04\x04%\x02\0\x12\x04\xd5\x02\
    \x04\x10\n\r\n\x05\x04%\x02\0\x06\x12\x04\xd5\x02\x04\x07\n\r\n\x05\x04%\
    \x02\0\x01\x12\x04\xd5\x02\x08\n\n\r\n\x05\x04%\x02\0\x03\x12\x04\xd5\
    \x02\r\x0e\n\x0c\n\x04\x04%\x02\x01\x12\x04\xd6\x02\x04\x10\n\r\n\x05\
    \x04%\x02\x01\x06\x12\x04\xd6\x02\x04\x07\n\r\n\x05\x04%\x02\x01\x01\x12\
    \x04\xd6\x02\x08\n\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xd6\x02\r\x0e\n\
    \x0c\n\x02\x04&\x12\x06\xd9\x02\0\xdc\x02\x01\n\x0b\n\x03\x04&\x01\x12\
    \x04\xd9\x02\x08\x10\n\x0c\n\x04\x04&\x02\0\x12\x04\xda\x02\x04\x14\n\r\
    \n\x05\x04&\x02\0\x06\x12\x04\xda\x02\x04\x07\n\r\n\x05\x04&\x02\0\x01\
    \x12\x04\xda\x02\x08\x0e\n\r\n\x05\x04&\x02\0\x03\x12\x04\xda\x02\x11\
    \x12\n\x0c\n\x04\x04&\x02\x01\x12\x04\xdb\x02\x04\x15\n\r\n\x05\x04&\x02\
    \x01\x06\x12\x04\xdb\x02\x04\x07\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xdb\
    \x02\x08\x0f\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xdb\x02\x12\x13\nd\n\x02\
    \x04'\x12\x06\xe3\x02\0\xe6\x02\x01\x1aV*\n\x20String\x20interpolation\n\
    \n\x20`\"Hello,\x20{name}\"\x20%%\x20{\"name\":\x20\"Bob\"}`\x20denotes\
    \x20`\"Hello,\x20Bob\"`\n\n\x0b\n\x03\x04'\x01\x12\x04\xe3\x02\x08\x17\n\
    \x0c\n\x04\x04'\x02\0\x12\x04\xe4\x02\x04\x10\n\r\n\x05\x04'\x02\0\x06\
    \x12\x04\xe4\x02\x04\x07\n\r\n\x05\x04'\x02\0\x01\x12\x04\xe4\x02\x08\n\
    \n\r\n\x05\x04'\x02\0\x03\x12\x04\xe4\x02\r\x0e\n\x0c\n\x04\x04'\x02\x01\
    \x12\x04\xe5\x02\x04\x10\n\r\n\x05\x04'\x02\x01\x06\x12\x04\xe5\x02\x04\
    \x07\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xe5\x02\x08\n\n\r\n\x05\x04'\x02\
    \x01\x03\x12\x04\xe5\x02\r\x0e\n\x1d\n\x02\x04(\x12\x06\xe9\x02\0\xec\
    \x02\x01\x1a\x0f\x20Concatenation\n\n\x0b\n\x03\x04(\x01\x12\x04\xe9\x02\
    \x08\x11\n\x0c\n\x04\x04(\x02\0\x12\x04\xea\x02\x04\x10\n\r\n\x05\x04(\
    \x02\0\x06\x12\x04\xea\x02\x04\x07\n\r\n\x05\x04(\x02\0\x01\x12\x04\xea\
    \x02\x08\n\n\r\n\x05\x04(\x02\0\x03\x12\x04\xea\x02\r\x0e\n\x0c\n\x04\
    \x04(\x02\x01\x12\x04\xeb\x02\x04\x10\n\r\n\x05\x04(\x02\x01\x06\x12\x04\
    \xeb\x02\x04\x07\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xeb\x02\x08\n\n\r\n\
    \x05\x04(\x02\x01\x03\x12\x04\xeb\x02\r\x0e\n\x1e\n\x02\x04)\x12\x06\xef\
    \x02\0\xf2\x02\x01\x1a\x10\x20Set\x20difference\n\n\x0b\n\x03\x04)\x01\
    \x12\x04\xef\x02\x08\x13\n\x0c\n\x04\x04)\x02\0\x12\x04\xf0\x02\x04\x10\
    \n\r\n\x05\x04)\x02\0\x06\x12\x04\xf0\x02\x04\x07\n\r\n\x05\x04)\x02\0\
    \x01\x12\x04\xf0\x02\x08\n\n\r\n\x05\x04)\x02\0\x03\x12\x04\xf0\x02\r\
    \x0e\n\x0c\n\x04\x04)\x02\x01\x12\x04\xf1\x02\x04\x10\n\r\n\x05\x04)\x02\
    \x01\x06\x12\x04\xf1\x02\x04\x07\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xf1\
    \x02\x08\n\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xf1\x02\r\x0e\n\x0c\n\x02\
    \x04*\x12\x06\xf4\x02\0\x80\x03\x01\n\x0b\n\x03\x04*\x01\x12\x04\xf4\x02\
    \x08\x12\n\x0e\n\x04\x04*\x08\0\x12\x06\xf5\x02\x02\xff\x02\x03\n\r\n\
    \x05\x04*\x08\0\x01\x12\x04\xf5\x02\x08\x1b\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xf6\x02\x04%\n\r\n\x05\x04*\x02\0\x06\x12\x04\xf6\x02\x04\x12\n\r\n\
    \x05\x04*\x02\0\x01\x12\x04\xf6\x02\x13\x20\n\r\n\x05\x04*\x02\0\x03\x12\
    \x04\xf6\x02#$\n\x0c\n\x04\x04*\x02\x01\x12\x04\xf7\x02\x04$\n\r\n\x05\
    \x04*\x02\x01\x06\x12\x04\xf7\x02\x04\x12\n\r\n\x05\x04*\x02\x01\x01\x12\
    \x04\xf7\x02\x13\x1f\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xf7\x02\"#\n\x0c\
    \n\x04\x04*\x02\x02\x12\x04\xf8\x02\x04\x1a\n\r\n\x05\x04*\x02\x02\x06\
    \x12\x04\xf8\x02\x04\x07\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf8\x02\x08\
    \x15\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xf8\x02\x18\x19\n\x0c\n\x04\x04*\
    \x02\x03\x12\x04\xf9\x02\x04\x1c\n\r\n\x05\x04*\x02\x03\x06\x12\x04\xf9\
    \x02\x04\n\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf9\x02\x0b\x17\n\r\n\x05\
    \x04*\x02\x03\x03\x12\x04\xf9\x02\x1a\x1b\n\x0c\n\x04\x04*\x02\x04\x12\
    \x04\xfa\x02\x04\x17\n\r\n\x05\x04*\x02\x04\x05\x12\x04\xfa\x02\x04\x08\
    \n\r\n\x05\x04*\x02\x04\x01\x12\x04\xfa\x02\t\x12\n\r\n\x05\x04*\x02\x04\
    \x03\x12\x04\xfa\x02\x15\x16\n\x0c\n\x04\x04*\x02\x05\x12\x04\xfb\x02\
    \x04\x16\n\r\n\x05\x04*\x02\x05\x05\x12\x04\xfb\x02\x04\x08\n\r\n\x05\
    \x04*\x02\x05\x01\x12\x04\xfb\x02\t\x11\n\r\n\x05\x04*\x02\x05\x03\x12\
    \x04\xfb\x02\x14\x15\n\x0c\n\x04\x04*\x02\x06\x12\x04\xfc\x02\x04\x19\n\
    \r\n\x05\x04*\x02\x06\x05\x12\x04\xfc\x02\x04\x08\n\r\n\x05\x04*\x02\x06\
    \x01\x12\x04\xfc\x02\t\x14\n\r\n\x05\x04*\x02\x06\x03\x12\x04\xfc\x02\
    \x17\x18\n\x0c\n\x04\x04*\x02\x07\x12\x04\xfd\x02\x04\x16\n\r\n\x05\x04*\
    \x02\x07\x05\x12\x04\xfd\x02\x04\x08\n\r\n\x05\x04*\x02\x07\x01\x12\x04\
    \xfd\x02\t\x11\n\r\n\x05\x04*\x02\x07\x03\x12\x04\xfd\x02\x14\x15\n\x0c\
    \n\x04\x04*\x02\x08\x12\x04\xfe\x02\x04\x1d\n\r\n\x05\x04*\x02\x08\x05\
    \x12\x04\xfe\x02\x04\x08\n\r\n\x05\x04*\x02\x08\x01\x12\x04\xfe\x02\t\
    \x18\n\r\n\x05\x04*\x02\x08\x03\x12\x04\xfe\x02\x1b\x1c\n\x0c\n\x02\x04+\
    \x12\x06\x82\x03\0\x85\x03\x01\n\x0b\n\x03\x04+\x01\x12\x04\x82\x03\x08\
    \x0e\n\x0c\n\x04\x04+\x02\0\x12\x04\x83\x03\x02\x13\n\r\n\x05\x04+\x02\0\
    \x05\x12\x04\x83\x03\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\x83\x03\t\
    \x0e\n\r\n\x05\x04+\x02\0\x03\x12\x04\x83\x03\x11\x12\n\x0c\n\x04\x04+\
    \x02\x01\x12\x04\x84\x03\x02\x13\n\r\n\x05\x04+\x02\x01\x05\x12\x04\x84\
    \x03\x02\x08\n\r\n\x05\x04+\x02\x01\x01\x12\x04\x84\x03\t\x0e\n\r\n\x05\
    \x04+\x02\x01\x03\x12\x04\x84\x03\x11\x12\n\x0c\n\x02\x04,\x12\x06\x87\
    \x03\0\x89\x03\x01\n\x0b\n\x03\x04,\x01\x12\x04\x87\x03\x08\x16\n\x0c\n\
    \x04\x04,\x02\0\x12\x04\x88\x03\x04\x18\n\r\n\x05\x04,\x02\0\x04\x12\x04\
    \x88\x03\x04\x0c\n\r\n\x05\x04,\x02\0\x06\x12\x04\x88\x03\r\x10\n\r\n\
    \x05\x04,\x02\0\x01\x12\x04\x88\x03\x11\x13\n\r\n\x05\x04,\x02\0\x03\x12\
    \x04\x88\x03\x16\x17\n\x0c\n\x02\x04-\x12\x06\x8b\x03\0\x8d\x03\x01\n\
    \x0b\n\x03\x04-\x01\x12\x04\x8b\x03\x08\x10\n\x0c\n\x04\x04-\x02\0\x12\
    \x04\x8c\x03\x05\x13\n\r\n\x05\x04-\x02\0\x05\x12\x04\x8c\x03\x05\n\n\r\
    \n\x05\x04-\x02\0\x01\x12\x04\x8c\x03\x0b\x0e\n\r\n\x05\x04-\x02\0\x03\
    \x12\x04\x8c\x03\x11\x12\n\x0c\n\x02\x04.\x12\x06\x8f\x03\0\x91\x03\x01\
    \n\x0b\n\x03\x04.\x01\x12\x04\x8f\x03\x08\x12\n\x0c\n\x04\x04.\x02\0\x12\
    \x04\x90\x03\x04\x18\n\r\n\x05\x04.\x02\0\x05\x12\x04\x90\x03\x04\t\n\r\
    \n\x05\x04.\x02\0\x01\x12\x04\x90\x03\n\x13\n\r\n\x05\x04.\x02\0\x03\x12\
    \x04\x90\x03\x16\x17\n\xb0\x01\n\x02\x04/\x12\x06\x96\x03\0\x9d\x03\x01\
    \x1a\xa1\x01\x20Unforgeable\x20names\x20resulting\x20from\x20`new\x20x\
    \x20{\x20...\x20}`\n\x20These\x20should\x20only\x20occur\x20as\x20the\
    \x20program\x20is\x20being\x20evaluated.\x20There\x20is\x20no\x20way\x20\
    in\n\x20the\x20grammar\x20to\x20construct\x20them.\n\n\x0b\n\x03\x04/\
    \x01\x12\x04\x96\x03\x08\x14\n\x0e\n\x04\x04/\x08\0\x12\x06\x97\x03\x04\
    \x9c\x03\x05\n\r\n\x05\x04/\x08\0\x01\x12\x04\x97\x03\n\x16\n\x0c\n\x04\
    \x04/\x02\0\x12\x04\x98\x03\x08$\n\r\n\x05\x04/\x02\0\x06\x12\x04\x98\
    \x03\x08\x10\n\r\n\x05\x04/\x02\0\x01\x12\x04\x98\x03\x11\x1f\n\r\n\x05\
    \x04/\x02\0\x03\x12\x04\x98\x03\"#\n\x0c\n\x04\x04/\x02\x01\x12\x04\x99\
    \x03\x08'\n\r\n\x05\x04/\x02\x01\x06\x12\x04\x99\x03\x08\x11\n\r\n\x05\
    \x04/\x02\x01\x01\x12\x04\x99\x03\x12\"\n\r\n\x05\x04/\x02\x01\x03\x12\
    \x04\x99\x03%&\n\x0c\n\x04\x04/\x02\x02\x12\x04\x9a\x03\x08+\n\r\n\x05\
    \x04/\x02\x02\x06\x12\x04\x9a\x03\x08\x13\n\r\n\x05\x04/\x02\x02\x01\x12\
    \x04\x9a\x03\x14&\n\r\n\x05\x04/\x02\x02\x03\x12\x04\x9a\x03)*\n\x0c\n\
    \x04\x04/\x02\x03\x12\x04\x9b\x03\x080\n\r\n\x05\x04/\x02\x03\x06\x12\
    \x04\x9b\x03\x08\x15\n\r\n\x05\x04/\x02\x03\x01\x12\x04\x9b\x03\x16+\n\r\
    \n\x05\x04/\x02\x03\x03\x12\x04\x9b\x03./\n\x0c\n\x02\x040\x12\x06\x9f\
    \x03\0\xa1\x03\x01\n\x0b\n\x03\x040\x01\x12\x04\x9f\x03\x08\x10\n\x0c\n\
    \x04\x040\x02\0\x12\x04\xa0\x03\x04\x11\n\r\n\x05\x040\x02\0\x05\x12\x04\
    \xa0\x03\x04\t\n\r\n\x05\x040\x02\0\x01\x12\x04\xa0\x03\n\x0c\n\r\n\x05\
    \x040\x02\0\x03\x12\x04\xa0\x03\x0f\x10\n\x0c\n\x02\x041\x12\x06\xa3\x03\
    \0\xa5\x03\x01\n\x0b\n\x03\x041\x01\x12\x04\xa3\x03\x08\x11\n\x0c\n\x04\
    \x041\x02\0\x12\x04\xa4\x03\x04\x12\n\r\n\x05\x041\x02\0\x05\x12\x04\xa4\
    \x03\x04\t\n\r\n\x05\x041\x02\0\x01\x12\x04\xa4\x03\n\r\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xa4\x03\x10\x11\n\x0c\n\x02\x042\x12\x06\xa7\x03\0\
    \xa9\x03\x01\n\x0b\n\x03\x042\x01\x12\x04\xa7\x03\x08\x13\n\x0c\n\x04\
    \x042\x02\0\x12\x04\xa8\x03\x04\x18\n\r\n\x05\x042\x02\0\x05\x12\x04\xa8\
    \x03\x04\t\n\r\n\x05\x042\x02\0\x01\x12\x04\xa8\x03\n\x13\n\r\n\x05\x042\
    \x02\0\x03\x12\x04\xa8\x03\x16\x17\n\n\n\x02\x043\x12\x04\xab\x03\0\x18\
    \n\x0b\n\x03\x043\x01\x12\x04\xab\x03\x08\x15b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
